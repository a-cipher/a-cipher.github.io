<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无名小站</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-20T10:18:18.820Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构之线性结构</title>
    <link href="http://example.com/article/37b7424c.html"/>
    <id>http://example.com/article/37b7424c.html</id>
    <published>2021-08-20T10:14:15.000Z</published>
    <updated>2021-08-20T10:18:18.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol><li><p>什么是线性表？</p><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><span id="more"></span><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。</p><p><strong>数组、链表、栈、队列是四种最常见的线性表.</strong></p></li><li><p>数组介绍？</p><p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p><p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li><p>什么是链表？</p><p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p><p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p><p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p></li><li><p>链表的优缺点？</p><ul><li>优点：<ul><li>增删数据方便</li><li>支持天然扩容</li></ul></li><li>缺点<ul><li>查找数据不方便</li><li>不支持随机访问</li></ul></li></ul></li><li><p>单链表？</p><p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8D%95%E9%93%BE%E8%A1%A82.png" alt="单链表"></p></li><li><p>循环链表？</p><p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A82.png" alt="循环链表"></p></li><li><p>双向链表？</p><p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p></li><li><p>双向循环链表？</p><p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p></li><li><p>数组 vs 链表</p><ul><li>数组支持随机访问，而链表不支持。</li><li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li><li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li></ul></li><li><p>Java中的双向链表（LinkedList）？</p><p>LinkedList 继承了 AbstractSequentialList 类。</p><p>LinkedList 实现了 Queue 接口，可作为队列使用。</p><p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p><p>LinkedList 实现了 Deque 接口，可作为队列使用。</p><p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p><p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p><p>详细方法参见：<a href="https://www.runoob.com/java/java-linkedlist.html">https://www.runoob.com/java/java-linkedlist.html</a></p></li></ol><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li><p>栈简介</p><p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p><p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设堆栈中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//最坏情况</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//顶端插入和删除元素Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%A0%88.png" alt="栈"></p></li><li><p>Java中栈的基本方法？</p><p>栈<code>Stack</code>的实现在java.util这个下面，继承于vector</p><p>主要方法：</p><ul><li>push 入栈</li><li>pop 返回栈顶元素并出栈</li><li>peek 返回栈顶元素不出栈</li><li>isEmpty() 栈是否为空</li><li>size() 栈的大小（继承自vector）</li><li>search() 从对象所在的栈顶部开始的基于1的位置; 返回值-1表示对象不在栈上</li></ul></li><li><p>栈的实现</p><p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p><p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p><blockquote><p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] storage;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;<span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//栈中元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GROW_FACTOR = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带初始容量的构造方法。默认容量为8</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带初始容量的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Capacity too small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.capacity = initialCapacity;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> <span class="keyword">int</span>[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            ensureCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        storage[count++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = capacity * GROW_FACTOR;</span><br><span class="line">        storage = Arrays.copyOf(storage, newCapacity);</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素并出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> storage[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素不出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage[count-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MyStack myStack = <span class="keyword">new</span> MyStack(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.push(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">4</span>);</span><br><span class="line">myStack.push(<span class="number">5</span>);</span><br><span class="line">myStack.push(<span class="number">6</span>);</span><br><span class="line">myStack.push(<span class="number">7</span>);</span><br><span class="line">myStack.push(<span class="number">8</span>);</span><br><span class="line">System.out.println(myStack.peek());<span class="comment">//8</span></span><br><span class="line">System.out.println(myStack.size());<span class="comment">//8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    System.out.println(myStack.pop());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(myStack.isEmpty());<span class="comment">//true</span></span><br><span class="line">myStack.pop();<span class="comment">//报错：java.lang.IllegalArgumentException: Stack is empty.</span></span><br></pre></td></tr></table></figure></li><li><p>栈的应用场景？</p><ol><li><p>实现浏览器的回退，前进功能</p><p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%80%92%E9%80%80%E5%92%8C%E5%89%8D%E8%BF%9B.png" alt="栈实现浏览器倒退和前进"></p></li><li><p>检查符号是否成对出现</p><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断该字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]” 、”([)]” 则不是。</p></blockquote><p>这个问题实际是 Leetcode 的一道题目（20题），我们可以利用栈 <code>Stack</code> 来解决这个问题。</p><ol><li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li><li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 括号之间的对应规则</span></span><br><span class="line">    HashMap&lt;Character, Character&gt; mappings = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    mappings.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappings.containsKey(chars[i])) &#123;</span><br><span class="line">            <span class="keyword">char</span> topElement = stack.empty() ? <span class="string">&#x27;#&#x27;</span> : stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (topElement != mappings.get(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li></ol></li><li><p>反转字符串</p><p>将字符串中的每个字符先入栈再出栈就可以了。</p></li><li><p>维护函数调用</p><p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p></li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol><li><p>队列简介</p><p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p><p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设队列中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//最坏情况</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//后端插入前端删除元素Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%98%9F%E5%88%97.png" alt="队列"></p></li><li><p>队列分类</p><p>主要分为单队列，循环队列</p><ol><li><p>单队列</p><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p><p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p><p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（<strong>越界</strong>）。</p><blockquote><p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front 指针指向对头元素</strong>，<strong>rear 指针指向队列最后一个元素的下一个位置</strong>，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p></blockquote><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%81%87%E6%BA%A2%E5%87%BA1.png" alt="顺序队列假溢出"></p></li><li><p>循环队列</p><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p><p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="循环队列"></p><p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p><ol><li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li><li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li></ol><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-%E5%A0%86%E6%BB%A1.png" alt="循环队列-队满"></p></li></ol></li><li><p>应用场景？</p><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p><ul><li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li><li><strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li><li>Linux 内核进程队列（按优先级排队）</li><li>现实生活中的派对，播放器上的播放列表;</li><li>消息队列</li><li>等等……</li></ul></li><li><p>Java中的队列？</p><p><code>Queue</code>是队列，只能一头进，另一头出。</p><p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code>Deque</code>。</p><p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p><ul><li>既可以添加到队尾，也可以添加到队首；</li><li>既可以从队首获取，又可以从队尾获取。</li></ul><p>我们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p><table><thead><tr><th align="left"></th><th align="left">Queue</th><th align="left">Deque</th></tr></thead><tbody><tr><td align="left">添加元素到队尾</td><td align="left">add(E e) / offer(E e)</td><td align="left">addLast(E e) / offerLast(E e)</td></tr><tr><td align="left">取队首元素并删除</td><td align="left">E remove() / E poll()</td><td align="left">E removeFirst() / E pollFirst()</td></tr><tr><td align="left">取队首元素但不删除</td><td align="left">E element() / E peek()</td><td align="left">E getFirst() / E peekFirst()</td></tr><tr><td align="left">添加元素到队首</td><td align="left">无</td><td align="left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td align="left">取队尾元素并删除</td><td align="left">无</td><td align="left">E removeLast() / E pollLast()</td></tr><tr><td align="left">取队尾元素但不删除</td><td align="left">无</td><td align="left">E getLast() / E peekLast()</td></tr></tbody></table></li></ol><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ol><li><p>什么是哈希函数？</p><p><strong>哈希函数就是根据确定根据这个函数和查找关键字key，可以直接确定查找值所在位置</strong>，而不需要一个个比较。这样就<strong>“预先知道”</strong>key所在的位置，直接找到数据，提升效率。<br>即地址<strong>index=H（key）</strong><br>说白了，hash函数就是根据key计算出应该存储地址的位置，而<strong>哈希表是基于哈希函数建立的一种查找表</strong>（也叫散列表）。</p></li><li><p>哈希函数的构造方法？</p><ul><li><p><strong>直接定制法</strong><br>哈希函数为关键字的线性函数如 H（key）=a*key+b<br>这种构造方法比较简便，均匀，但是有很大限制，仅限于地址大小=关键字集合的情况</p></li><li><p><strong>数字分析法</strong><br>此种方法通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况，比如上面的例子，我们事先知道这个班级的学生出生在同一年，同一个地区。</p></li><li><p><strong>平方取中法</strong><br>如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。<br>这种方法适合事先不知道数据并且数据长度较小的情况</p></li><li><p><strong>折叠法</strong><br>如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为hash地址<br>该方法适用于数字位数较多且事先不知道数据分布的情况</p></li><li><p><strong>除留余数法</strong>用的较多  </p><p>H（key）=key MOD p （p&lt;=m m为表长）<br>很明显，如何选取p是个关键问题。</p></li><li><p><strong>随机数法</strong> H（key） =Random（key） 取关键字的随机函数值为它的散列地址</p></li></ul></li><li><p><strong>hash函数设计的考虑因素</strong></p><ol><li>计算散列地址所需要的时间（即hash函数本身不要太复杂）</li><li>关键字的长度</li><li>表长</li><li>关键字分布是否均匀，是否有规律可循</li><li>设计的hash函数在满足以上条件的情况下尽量减少冲突</li></ol></li><li><p>什么是哈希冲突？</p><p>不同的key值产生相同的地址。</p></li><li><p>哈希冲突的解决？</p><ol><li>开放定制法</li><li>链地址法</li><li>公共溢出区法<br>建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。</li><li>再散列法<br>准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……<br>重点了解一下<strong>开放定制法</strong>和<strong>链地址法</strong></li></ol></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p><p><a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p><p><a href="https://blog.csdn.net/u011109881/article/details/80379505">https://blog.csdn.net/u011109881/article/details/80379505</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a></p><p><a href="https://www.pdai.tech/md/algorithm/alg-basic-tree-search.html">https://www.pdai.tech/md/algorithm/alg-basic-tree-search.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线性结构&quot;&gt;&lt;a href=&quot;#线性结构&quot; class=&quot;headerlink&quot; title=&quot;线性结构&quot;&gt;&lt;/a&gt;线性结构&lt;/h1&gt;&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是线性表？&lt;/p&gt;
&lt;p&gt;线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/article/f7ede91d.html"/>
    <id>http://example.com/article/f7ede91d.html</id>
    <published>2021-08-13T09:51:50.000Z</published>
    <updated>2021-08-13T10:10:26.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;复习Java基础，记录一下一些重要的知识点。</p><span id="more"></span><p>&emsp;&emsp;主要内容来自Github上的<a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a>，仅作个人学习。</p><h2 id="概念常识"><a href="#概念常识" class="headerlink" title="概念常识"></a>概念常识</h2><ol><li><p>什么是JVM?</p><p>JVM是Java Virtual Machine（Java虚拟机），是运行Java字节码的虚拟机。针对不同系统有不同实现，目的是使用相同的字节码，给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p></li><li><p>什么是字节码？</p><p>JVM可以理解的代码叫字节码（.class文件），它不面向任何特定的处理器，只面向虚拟机。</p></li><li><p><strong>Java 程序从源代码到运行一般有哪些步骤？</strong></p><p><img src="/article/f7ede91d/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="运行过程"></p></li><li><p>JDK 和 JRE的概念？</p><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p></li><li><p>为什么说Java“编译与解释并存”？</p><p>编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p></li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>字符型常量和字符串常量的区别？</p><ul><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li><li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li></ul></li><li><p>标识符和关键字的区别？</p><p>简单来说，标识符就相当于名字。关键字就是具有特殊含义的标识符，已经有了特定的含义，只能用于特定的地方。</p></li><li><p>类和对象之间的关系？</p><p>对象是类实例化出来的,对象中含有类的属性,类是对象的抽象。用static修饰的方法是静态的方法或称为共享方法，一般用类名直接调用。</p></li><li><p>什么是泛型？</p><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说<strong>类型擦除</strong> 。</p></li><li><p>泛型的使用方式？</p><ul><li>泛型类，</li><li>泛型接口</li><li>泛型方法</li></ul></li><li><p>常用的通配符？</p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul></li><li><p>==和 equals 的区别</p><ul><li><p>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p></li><li><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></li><li><p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p></li><li><p>一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</p></li><li><p>```java<br>public class test1 {</p><pre><code>public static void main(String[] args) &#123;    String a = new String(&quot;ab&quot;); // a 为一个引用    String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样    String aa = &quot;ab&quot;; // 放在常量池中    String bb = &quot;ab&quot;; // 从常量池中查找    if (aa == bb) // true        System.out.println(&quot;aa==bb&quot;);    if (a == b) // false，非同一对象        System.out.println(&quot;a==b&quot;);    if (a.equals(b)) // true        System.out.println(&quot;aEQb&quot;);    if (42 == 42.0) &#123; // true        System.out.println(&quot;true&quot;);    &#125;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。</span><br><span class="line"></span><br><span class="line">   - 当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。</span><br><span class="line"></span><br><span class="line">   - **敲重点：==比较的是基本数据类型的值，引用类型对象的内存地址；equals比较的是对象是否相等，当调用的equals是被重写的时候，比较的是对象里面的值。**</span><br><span class="line"></span><br><span class="line">8. 什么是hashCode()?</span><br><span class="line"></span><br><span class="line">   `hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</span><br><span class="line"></span><br><span class="line">9. 为什么重写 equals 时必须重写 hashCode 方法？？</span><br><span class="line"></span><br><span class="line">   如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**</span><br><span class="line"></span><br><span class="line">10. 相同hashCode值，他们不一定相等？</span><br><span class="line"></span><br><span class="line">    因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是**不同的对象得到相同的 `hashCode`**）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 基本数据类型</span><br><span class="line"></span><br><span class="line">1. Java中8种基本数据类型有哪些？</span><br><span class="line"></span><br><span class="line">   | 基本类型  | 位数 | 字节 | 默认值  |</span><br><span class="line">   | --------- | ---- | ---- | ------- |</span><br><span class="line">   | `int`     | 32   | 4    | 0       |</span><br><span class="line">   | `short`   | 16   | 2    | 0       |</span><br><span class="line">   | `long`    | 64   | 8    | 0L      |</span><br><span class="line">   | `byte`    | 8    | 1    | 0       |</span><br><span class="line">   | `char`    | 16   | 2    | &#x27;u0000&#x27; |</span><br><span class="line">   | `float`   | 32   | 4    | 0f      |</span><br><span class="line">   | `double`  | 64   | 8    | 0d      |</span><br><span class="line">   | `boolean` | 1    |      | false   |</span><br><span class="line"></span><br><span class="line">   - Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。</span><br><span class="line"></span><br><span class="line">   - `char a = &#x27;h&#x27;`char :单引号，`String a = &quot;hello&quot;` :双引号。</span><br><span class="line"></span><br><span class="line">   - 这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。</span><br><span class="line"></span><br><span class="line">   - 包装类型不赋值就是 `Null` ，而基本类型有默认值且不是 `Null`。</span><br><span class="line"></span><br><span class="line">2. 什么是自动装箱和拆箱？</span><br><span class="line"></span><br><span class="line">   - **装箱**：将基本类型用它们对应的引用类型包装起来；</span><br><span class="line"></span><br><span class="line">   - **拆箱**：将包装类型转换为基本数据类型；</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     Integer i = 10;  //装箱</span><br><span class="line">     int n = i;   //拆箱</span><br><span class="line">     </span><br><span class="line">     //Integer i = 10 等价于 Integer i = Integer.valueOf(10)</span><br><span class="line">     //int n = i 等价于 int n = i.intValue();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>8 种基本类型的包装类和常量池?</p><p>Java 基本类型的包装类的大部分都实现了常量池技术。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code></p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p></li><li><p><strong>整型包装类对象之间值的比较</strong>?</p><p><img src="https://img-blog.csdnimg.cn/20210422164544846.png" alt="img"></p></li><li><p>什么是引用数据类型？有哪些？</p><p>引用类型在堆里，基本类型在栈里。栈空间小且连续，往往会被放在缓存。引用类型cache miss率高且要多一次解引用。对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高</p><p>引用数据类型主要包括：类，接口，数组</p></li></ol><h2 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h2><ol><li><p>final</p><p><strong>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li><strong>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</strong></li><li><strong>final 修饰的方法不能被重写；</strong></li><li><strong>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></li></ol></li><li><p>static</p><ol><li><strong>修饰成员变量和成员方法</strong>：被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过<strong>类名调用</strong>。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</li><li>静态代码块</li><li>修饰类(只能修饰内部类)</li><li>静态导包(用来导入类中的静态资源，1.5 之后的新特性)</li></ol></li><li><p>this</p><p>this 关键字用于引用类的当前实例</p></li><li><p>super</p><p>super 关键字用于从子类访问父类的变量和方法</p></li><li><p>this和super使用注意？</p><ul><li>在构造器中使用 <code>super()</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super 不能用在 static 方法中。 <strong>this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong></li></ul></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><p>在一个静态方法内调用一个非静态成员为什么是非法的?</p><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p></li><li><p>静态方法与实例化方法的区别？</p><ul><li>调用方式不同<ul><li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</li></ul></li><li><strong>访问类成员是否存在限制</strong><ul><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li></ul></li></ul></li><li><p>Java中为什么只有值传递？</p><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容</strong>。</p></li><li><p>方法参数的使用情况？</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul></li><li><p>重载和重写的区别？</p><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table></li><li><p>深拷贝 vs 浅拷贝</p><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol><li><p>面向对象和面向过程的区别？</p><ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li><li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul></li><li><p>成员变量与局部变量的区别有哪些？</p><ol><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol></li><li><p>对象实体与对象引用的区别？</p><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p></li><li><p>对象相等和指向他们的引向相等有何不同？</p><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p></li><li><p>构造方法是否可以被重写？</p><p>构造方法不可以被重写，但是可以重载。</p></li><li><p>面向对象的三大特征？</p><ul><li>封装 ：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li><li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。<ul><li><strong>关于继承如下 3 点请记住：</strong><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></li></ul></li><li>多态：对于一个方法，我们有不同的操作方式。<ul><li><strong>多态的特点:</strong><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul></li></ul></li></ul></li><li><p>String StringBuffer 和 StringBuilder 的区别是什么?</p><ol><li>可变性方面<ul><li>string由final修饰，不可变</li><li>StringBuilder 和 StringBuffer 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</li></ul></li><li>线程安全方面<ul><li>string 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li></ul></li><li>性能<ul><li>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul></li><li>使用总结<ul><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ul></li></ol></li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol><li><p>什么是反射？</p><p>Java 反射，就是在运行状态中。</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li></ul></li><li><p>反射机制的优缺点？</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul></li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol><li><p>异常层次结构图？</p><p><img src="/article/f7ede91d/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Java异常类层次结构图"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li><li><p>受检查异常和不受检查异常？</p><p><img src="/article/f7ede91d/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt="Java异常类层次结构图2"></p><ul><li>不受检查异常主要是<code>RuntimeException</code>及其子类；Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li><li>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。</li></ul></li><li><p>Throwable 类常用方法?</p><ul><li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul></li><li><p>try-catch-finally?</p><ul><li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li><li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。<ul><li><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong><ol><li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol></li></ul></li></ul></li><li><p>try-with-resourse(java7新增)?</p><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol></li></ol><h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><ol><li><p>什么是序列化？什么是反序列化？</p><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li><li>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></li></ul></li><li><p>有些字段不想进行序列化，怎么解决？</p><p>使用 <code>transient</code> 关键字修饰。<code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul></li><li><p>Java中键盘输入的方式？</p><p>方法 1：通过 <code>Scanner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>方法 2：通过 <code>BufferedReader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure></li><li><p>IO流的种类？</p><p><img src="/article/f7ede91d/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p></li><li><p>字节流和字符流？</p><p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p></li></ol><h2 id="疑难点"><a href="#疑难点" class="headerlink" title="疑难点"></a>疑难点</h2><ol><li><p>equals的使用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;SnailClimb&quot;</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="comment">//1.&quot;SnailClimb&quot;.equals(str);// false</span></span><br><span class="line"><span class="comment">//2.Objects.equals(null,&quot;SnailClimb&quot;);// false</span></span><br></pre></td></tr></table></figure></li><li><p>BigDecimsl的作用？</p><p><strong>来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); </span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure></li><li><p>BigDecimal 的使用注意事项</p><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src="/article/f7ede91d/BigDecimal.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p></li><li><p>基本数据类型与包装数据类型的使用标准？</p><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。 （rpc 远程过程调用）</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;复习Java基础，记录一下一些重要的知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识总结</title>
    <link href="http://example.com/article/df19d329.html"/>
    <id>http://example.com/article/df19d329.html</id>
    <published>2021-08-11T09:38:57.000Z</published>
    <updated>2021-08-11T10:40:11.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;MySQL是常用的关系型数据库，MySQL作为企业中常用的数据库之一，了解MySQL并熟练掌握MySQL的使用是十分重要。现将MySQL知识总结记录下来，方便个人学习查阅。主要知识来源GitHub开源项目<a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a>。</p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>什么是数据库,数据库管理系统,数据库系统,数据库管理员?</p><ul><li><strong>数据库</strong> :数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用语用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator,简称 DBA)负责全面管理和控制数据库系统。</li></ul></li><li><p>什么是关系型数据库？</p><p>建立在关系模型基础上的数据库。关系模型表明了数据库所存数据之间的联系（一对一，一对多，多对多）。</p><p>大部分关系型数据库使用SQL来操作数据库中的数据。常见关系型数据库MySQL（3306），Oracle，SQL server等。</p></li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ol><li><p>查看MySQL存储引擎命令？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p>默认InnoDB，属于事务性引擎，支持事务</p></li><li><p>MyISAM 和 InnoDB 的区别？</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>🌈 拓展一下：</p><p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p>🌈 拓展一下：</p><ul><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p><p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p></li><li><p>MyISAM 和 InnoDB 的选择问题？</p><p>大多情况选择InnoDB，MyISAM不支持事务，崩溃恢复！</p></li></ol><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><ol><li><p>什么是锁机制？</p><p>锁是计算机协调多个进程或线程并发访问某一资源的一种机制。</p><p>从性能上来分，锁分为乐观锁和悲观锁。</p><p>从数据库操作的类型分，锁分读锁和写锁（都是悲观锁）。</p><p>从操作数据库的粒度来说，分表锁和行锁</p></li><li><p>悲观锁？</p><p>当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p><p>悲观锁的实现：</p><ol><li>传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</li><li>Java 里面的同步 synchronized关键字的实现。</li></ol></li><li><p>乐观锁？</p><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。</p><p>乐观锁的实现：</p><ol><li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li><li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功</li></ol></li><li><p>读锁和写锁？</p><p>读锁（共享锁，S锁 Shared）：针对同一份数据，多个读操作可以同时进行并且不会相互影响</p><p>写锁（排它锁，X锁 eXclusive）：在当前写操作完成前，会阻断其他一切的锁</p></li><li><p><strong>表级锁和行级锁对比？</strong></p><ul><li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li><li>考虑上述特点，表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的web应用；而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。</li></ul></li><li><p>InnoDB 存储引擎锁的机制有哪些？</p><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li></ul></li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol><li><p>什么是事务？</p><p>逻辑上的一组操作，要不都执行，要不都不执行。</p></li><li><p>事务的四大特性ACID（关系型数据库事务都有这个特点）？</p><ul><li><strong>原子性</strong> Atomicity 事务是最小的执行单位，不能再分割。要不都执行，要不都不执行</li><li><strong>一致性</strong> Consistency 执行事务前后，数据需要保持一致</li><li><strong>隔离性</strong> Isolation 并发访问时，一个用户事务不能被其他事务所干扰</li><li><strong>持久性</strong> Durability 事务提交之后，对数据库中的改变是持久的</li></ul></li><li><p>常见的并发异常？</p><ul><li>脏读：一个事务读到了另外一个事务修改了但是没有提交的数据</li><li>不可重复读：一个事务读多次同一数据，中途该数据被另外一个事务读取并修改，导致两次读到的数据不一致</li><li>幻读：一个事务读多次同一数据，中途该数据被另外一个并发事务插入或者删除，导致随后读取的数据发生变化，像幻觉一样</li><li>丢失修改：两个事务先后访问并修改数据，导致第一个修改的数据丢失</li></ul></li><li><p>事务隔离级别？</p><ul><li><p>READ-UNCOMMITTED 读取未提交</p></li><li><p>READ-COMMITTED 读取已提交，可避免脏读</p></li><li><p>REPEATABLE-READ 可重复读，多次读取数据一致，可避免脏读和不可重复读</p></li><li><p>SERIALIZABLE 可串行化，所有事务依次执行，可防止脏读，不可重复读，幻读</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></li></ul></li><li><p>MySQL默认隔离级别？</p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p></li></ol><h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><ol><li><p>什么是mvvc?</p><p>英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。某种程度上就是乐观锁的一种实现方式。在Java编程中，如果把乐观锁看成一个接口，MVCC便是这个接口的一个实现类而已。</p></li><li><p>MVVC机制的实现？</p><p>MVCC机制的实现是通过read-view机制与undo日志版本链对比，来使得不同的事务会根据数据版本链进行比对来读取同一条数据在版本链上的不同版本数据，进行数据的隔离。下面通过一张图来详细描述MVCC的实现机制。</p><p>首先我们介绍一下日志版本链，日志版本链是指一行数据被多个事务依次修改后，每次事务修改完，mysql都会保留修改前的数据的undo回滚日志，同时使用了两个隐藏字段trx_id(事务号)和roll_pointer(回滚指针)把这些回滚日志串联起来形成一个版本链。具体的如图所示：</p><p>图中每一行代表一个回滚日志，每个日志末尾都有一个roll_pointer指向上一条日志。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/paRXy9ic0MZNpBBEyR8WP6eaD1EGWUbMia2uEdpkQL0ZhLgBCf955qN3LGMAwkO2dZwu56NZpAMBQNSD0T9Hzn7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>当事务开启时，执行任何查询sql都会生成当前事务的一致性视图read-view，生成的视图在事务结束之前都不会变化，这个视图由查询时所有未提交事务id数组和已创建的最大事务id组成。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/paRXy9ic0MZNpBBEyR8WP6eaD1EGWUbMia3xbmAo1Cf9ZHB2Hh4HlB0LmibyTR9ufMKjmFgYZ1fK6POMrh3ibYIofA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>在我们当前的日志版本链内，查询了一条数据，创建了一个对应的read-view，那么它应该是这样，[80,81,82],202 ,数组内最小的id为min_id,最大的事务id(max_id)是202。</p><p>具体的版本链比对规则：</p><ol><li><p>如果trx_id&lt;min_id , 表示这个版本是已提交的事务产生的，可见</p></li><li><p>如果trx_id &gt;max_id，表示是由生成read-view之后的事务版本生成的，不可见</p></li><li><p>如果trx_id落在min_id和max_id之间，分为两种情况：</p></li><li><ol><li>如果trx_id在read-view的数组内，不可见</li><li>如果trx_id不在read-view的数组内，可见</li></ol></li></ol><p>PS：事务的trx_id生成规则是依次递增的，所以后面生成的trx_id一定比前面的大。事务的真正启动，是在执行第一个修改操作数据库的语句开始的，查询语句不生成事务id。</p><p>最后，再提供一张图方便大家理解：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/paRXy9ic0MZNpBBEyR8WP6eaD1EGWUbMiaoVRK5ibI0AYIktrbibKicWcUZibsNllxkW0NantMiaiaOGgb9R3WRFUPPkNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li><p>什么是索引，有什么用？</p><p>索引是一种快速查询和检索数据的数据结构，作用相当于目录的作用。常见的索引有：B树，B+树和 Hash。</p></li><li><p>索引的优缺点？</p><ul><li>优点：加快数据检索速度，创建唯一性索引，可以保证每一行数据的唯一性</li><li>缺点：创建维护索引需要时间，同时占用一定空间。</li></ul></li><li><p>Hash?</p><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p></li><li><p>MySQL中不使用Hash作为索引数据结构的原因？</p><p><strong>1.Hash 冲突问题</strong> ：多个不同的 key 最后得到的 index 相同。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p></li><li><p>B 树&amp; B+树 ？</p><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li><p>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p><p><img src="https://img-blog.csdnimg.cn/20210420165409106.png" alt="img"></p></li></ul></li><li><p>索引类型？</p><ul><li>主键索引 数据表的主键列使用的就是主键索引。</li><li>二级索引（辅助索引） <strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></li></ul></li><li><p>聚集索引？</p><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>优点：查询速度快，整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><p>缺点：依赖有序的数据，更新代价大。</p></li><li><p>非聚集索引？</p><p><strong>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</strong></p><p>优点：<br>更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p>缺点：<br>跟聚集索引一样，非聚集索引也依赖于有序的数据<br>可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p></li><li><p>创建索引的注意事项？</p><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><p><strong>4.注意避免冗余索引</strong> 。</p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p></li></ol><h2 id="语句执行流程"><a href="#语句执行流程" class="headerlink" title="语句执行流程"></a>语句执行流程</h2><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎<ul><li>先判断你有没有权限</li><li>查询缓存中是否有数据（MySQL 8.0 之后移除）</li><li>分析查询语句，词条分析（提取其中关键字）+ 语法分析（判断是否符合语法）</li><li>优化器确定执行的方案，据自己的优化算法进行选择执行效率最好的一个方案（不一定最好）</li><li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li></ul></li><li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)<ul><li>update tb_student A set A.age=’19’ where A.name=’ 张三 ‘;</li><li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li><li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul></li></ul><h2 id="存储时间"><a href="#存储时间" class="headerlink" title="存储时间"></a>存储时间</h2><ol><li><p>MySQL中使用什么存储时间好？</p><p>切记不要用字符串存储时间，占用空间大，日期效率低</p><p>每种方式都有各自的优势，根据实际场景才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p></li></ol><p><img src="/article/df19d329/%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.jpg" alt="常用日期存储方式"></p><h2 id="易混点"><a href="#易混点" class="headerlink" title="易混点"></a>易混点</h2><ol><li>drop , truncate , delete 之间的区别？<ul><li>drop(丢弃数据): <code>drop table 表名</code> ，删表</li><li>truncate (清空数据) : <code>truncate table 表名</code> ，清空表的数据</li><li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除具体的某一行数据</li><li>drop和truncate属于DDL语言，数据定义语言，delete属于DML语言，数据操作语言</li></ul></li><li>……</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>本文主要知识来源于网络，仅作为个人学习使用</strong></p><p>参考来源：</p><p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p><p><a href="https://www.jianshu.com/p/d2ac26ca6525">https://www.jianshu.com/p/d2ac26ca6525</a></p><p><a href="https://mp.weixin.qq.com/s/7KblQbpWXTW3I9MHWRvnkg">https://mp.weixin.qq.com/s/7KblQbpWXTW3I9MHWRvnkg</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MySQL是常用的关系型数据库，MySQL作为企业中常用的数据库之一，了解MySQL并熟练掌握MySQL的使用是十分重要。现将MySQL知识总结记录下来，方便个人学习查阅。主要知识来源GitHub开源项目&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide&quot;&gt;JavaGuide&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus代码生成</title>
    <link href="http://example.com/article/7cc9a691.html"/>
    <id>http://example.com/article/7cc9a691.html</id>
    <published>2021-08-05T07:54:30.000Z</published>
    <updated>2021-08-05T10:05:10.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;MyBatis-Plus某种程度上属于MyBatis的升级版，在许多方面都使我们的开发更加简便。这篇文章介绍在SpringBoot中怎么使用MyBatis的代码生成器。AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p><span id="more"></span><h1 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h1><p>&emsp;&emsp;我们可以创建一个SpringBoot项目<code>CodeGenerator</code>专门用于生成我们的MyBatis_plus代码，每次有新项目都可以通过这个项目来生成我们需要的实体类，Mapper等代码。</p><p>项目创建完成之后，需要引入相应的依赖，具体依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web场景--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--MySQL数据库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Mybatis-Plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--代码生成器依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>Lombok是一个插件，可以通过注解免去生成get，set等方法</li><li>数据源可以根据自己需要更换，这里使用的是Druid</li><li>MyBatis-Plus 从 <code>3.0.3</code> 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖</li><li>模板引擎有多种，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎</li></ul><h1 id="添加代码生成类"><a href="#添加代码生成类" class="headerlink" title="添加代码生成类"></a>添加代码生成类</h1><p>在<code>CodeGenerator\src\main\java\com\example\codegenerator\</code>目录下添加代码生成类。</p><p>主要需要修改的部分如下</p><ol><li><p>全局配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>); <span class="comment">//生成路径</span></span><br><span class="line">gc.setAuthor(<span class="string">&quot;作者名字&quot;</span>);</span><br><span class="line">gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">mpg.setGlobalConfig(gc);</span><br></pre></td></tr></table></figure></li><li><p>数据源配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line"><span class="comment">//数据库地址，把student更换成你的数据库名即可</span></span><br><span class="line">dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/student?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);</span><br><span class="line">dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="comment">//数据库类型</span></span><br><span class="line">dsc.setUsername(<span class="string">&quot;数据库用户名&quot;</span>);</span><br><span class="line">dsc.setPassword(<span class="string">&quot;数据库密码&quot;</span>);</span><br><span class="line">mpg.setDataSource(dsc);</span><br></pre></td></tr></table></figure></li><li><p>包配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">pc.setModuleName(scanner(<span class="string">&quot;模块名&quot;</span>));</span><br><span class="line">pc.setParent(<span class="string">&quot;com.example.codegenerator&quot;</span>); <span class="comment">//代码生成的文件目录，不存在则会新建</span></span><br><span class="line">mpg.setPackageInfo(pc);</span><br></pre></td></tr></table></figure></li><li><p>更改模板引擎</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果模板引擎是 freemarker</span></span><br><span class="line"><span class="comment">// String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span></span><br><span class="line"><span class="comment">// 如果模板引擎是 velocity</span></span><br><span class="line">String templatePath = <span class="string">&quot;/templates/mapper.xml.vm&quot;</span>;</span><br><span class="line"><span class="comment">//其他模板引擎同理</span></span><br></pre></td></tr></table></figure></li><li><p>策略配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line"><span class="comment">//        strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span></span><br><span class="line">strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 公共父类</span></span><br><span class="line"><span class="comment">// strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span></span><br><span class="line"><span class="comment">// 写于父类中的公共字段</span></span><br><span class="line">strategy.setSuperEntityColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">strategy.setInclude(scanner(<span class="string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line">strategy.setTablePrefix(pc.getModuleName() + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">mpg.setStrategy(strategy);</span><br><span class="line"><span class="comment">// mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span></span><br><span class="line">mpg.setTemplateEngine(<span class="keyword">new</span> VelocityTemplateEngine()); <span class="comment">//根据你的模板引擎更改</span></span><br><span class="line">mpg.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>支持自定义配置</p><p>自定义配置优先！</p></li><li><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 读取控制台内容</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scanner</span><span class="params">(String tip)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        StringBuilder help = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        help.append(<span class="string">&quot;请输入&quot;</span> + tip + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MybatisPlusException(<span class="string">&quot;请输入正确的&quot;</span> + tip + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// gc.setSwagger2(true); 实体属性 Swagger2 注解</span></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/student?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);</span><br><span class="line">        <span class="comment">// dsc.setSchemaName(&quot;public&quot;);</span></span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(scanner(<span class="string">&quot;模块名&quot;</span>));</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.example.codegenerator&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义配置</span></span><br><span class="line">        InjectionConfig cfg = <span class="keyword">new</span> InjectionConfig() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// to do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果模板引擎是 freemarker</span></span><br><span class="line"><span class="comment">//        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span></span><br><span class="line">        <span class="comment">// 如果模板引擎是 velocity</span></span><br><span class="line">        String templatePath = <span class="string">&quot;/templates/mapper.xml.vm&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义输出配置</span></span><br><span class="line">        List&lt;FileOutConfig&gt; focList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义配置会被优先输出</span></span><br><span class="line">        focList.add(<span class="keyword">new</span> FileOutConfig(templatePath) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">outputFile</span><span class="params">(TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span></span><br><span class="line">                <span class="keyword">return</span> projectPath + <span class="string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()</span><br><span class="line">                        + <span class="string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cfg.setFileCreate(new IFileCreate() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span></span><br><span class="line"><span class="comment">                // 判断自定义文件夹是否需要创建</span></span><br><span class="line"><span class="comment">                checkDir(&quot;调用默认方法创建的目录，自定义目录用&quot;);</span></span><br><span class="line"><span class="comment">                if (fileType == FileType.MAPPER) &#123;</span></span><br><span class="line"><span class="comment">                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false</span></span><br><span class="line"><span class="comment">                    return !new File(filePath).exists();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                // 允许生成模板文件</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        mpg.setCfg(cfg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置模板</span></span><br><span class="line">        TemplateConfig templateConfig = <span class="keyword">new</span> TemplateConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置自定义输出模板</span></span><br><span class="line">        <span class="comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span></span><br><span class="line">        <span class="comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span></span><br><span class="line">        <span class="comment">// templateConfig.setService();</span></span><br><span class="line">        <span class="comment">// templateConfig.setController();</span></span><br><span class="line"></span><br><span class="line">        templateConfig.setXml(<span class="keyword">null</span>);</span><br><span class="line">        mpg.setTemplate(templateConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line"><span class="comment">//        strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 公共父类</span></span><br><span class="line"><span class="comment">//        strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span></span><br><span class="line">        <span class="comment">// 写于父类中的公共字段</span></span><br><span class="line">        strategy.setSuperEntityColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        strategy.setInclude(scanner(<span class="string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setTablePrefix(pc.getModuleName() + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"><span class="comment">//        mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span></span><br><span class="line">        mpg.setTemplateEngine(<span class="keyword">new</span> VelocityTemplateEngine());</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的配置修改可参见<a href="https://mp.baomidou.com/config/generator-config.html#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">官网</a></p></li></ol><h1 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h1><p>&emsp;&emsp;点击运行上述<code>codegenerator</code>输入生成的文件目录，再输入需要生成的表，多个表之间用英文逗号隔开，回车即可自动生成相应的代码，如下：</p><p><img src="/article/7cc9a691/image-20210805162503596.png" alt="生成目录"></p><p>同时生成的代码会根据你数据库表的注释生成相应的注释</p><p><img src="/article/7cc9a691/image-20210805162732055.png" alt="生成的实体类"></p><p>注：mysql数据库注释使用<code>comment</code>，可在建表时注释，也可后续添加</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.baomidou.com/guide/generator.html#">https://mp.baomidou.com/guide/generator.html#</a></p><p><a href="https://mp.baomidou.com/config/generator-config.html#">https://mp.baomidou.com/config/generator-config.html#</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MyBatis-Plus某种程度上属于MyBatis的升级版，在许多方面都使我们的开发更加简便。这篇文章介绍在SpringBoot中怎么使用MyBatis的代码生成器。AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="springboot" scheme="http://example.com/tags/springboot/"/>
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus整合SpringBoot</title>
    <link href="http://example.com/article/a09c4a7b.html"/>
    <id>http://example.com/article/a09c4a7b.html</id>
    <published>2021-08-03T09:04:16.000Z</published>
    <updated>2021-08-05T08:33:38.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> &emsp;&emsp;MyBatis-Plus（简称 MP）是一个Mybatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。刚好最近学到springboot，来实现一个简单的整合。</p><span id="more"></span><h1 id="快速实现"><a href="#快速实现" class="headerlink" title="快速实现"></a>快速实现</h1><ol><li><p>官方介绍：<a href="https://mp.baomidou.com/guide">https://mp.baomidou.com/guide</a></p><p>gitee源码地址：<a href="https://gitee.com/baomidou/mybatis-plus">https://gitee.com/baomidou/mybatis-plus</a></p></li><li><p>快速实现</p><ul><li><p>导入依赖</p><ul><li><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ul></li><li><p>编写配置类，默认已经配置好了不少</p><ul><li>注：<strong>使用mybatis-plus之后，原先配置的mybatis会失效，需要重新在mybatis-plus配置</strong></li></ul></li><li><p>编写实体类</p><ul><li>```Java<br>//该注解可以表明该字段不在数据库，否则mybatis-plus使用报错<br>@TableField(exist = false)<br>private String userName;<br>@TableField(exist = false)<br>private String password;//@TableName(“user_tbl”),默认根据类名获取数据库中的表名，当名字不一致，可以使用该注解指定数据库表<br>//@TableName(“user_tbl”)注解加在类前面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 编写mapper类</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //BaseMapper里面包括了基本的CRUD方法，我们不用额外再写</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试输出</p><pre><code>@Autowiredprivate UserMapper userMapper;@Testpublic void testSelect() &#123;    System.out.println((&quot;----- selectAll method test ------&quot;));    List&lt;User&gt; userList = userMapper.selectList(null);    Assert.assertEquals(5, userList.size());    userList.forEach(System.out::println);&#125;</code></pre></li><li><p>具体可参照官方文档</p></li></ul></li></ol><h1 id="CRUD功能的实现"><a href="#CRUD功能的实现" class="headerlink" title="CRUD功能的实现"></a>CRUD功能的实现</h1><ul><li><p>在上一部分的基础上进行</p></li><li><p>暂时只实现了删除</p></li><li><p>service层 Userservice 继承IService<User></p><ul><li>```java<br>public interface UserService extends IService<User> {<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 实现service接口</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    @Service</span><br><span class="line">    public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>控制层实现数据的展示和数据删除</p><ul><li><p>RedirectAttributes重定向之后可以携带参数</p></li><li><p>```Java</p><pre><code>@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)public String deleteUser(@PathVariable(&quot;id&quot;) Integer id,                         @RequestParam(&quot;pn&quot;) Integer pn,                         RedirectAttributes rn)&#123;    userService.removeById(id);    rn.addAttribute(pn);    return &quot;redirect:/dynamic_table&quot;;&#125;@GetMapping(&quot;/dynamic_table&quot;)public String dynamic_table(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn, Model model)&#123;        List&lt;User&gt; list = userService.list();</code></pre><p>//        model.addAttribute(“list”,list);</p><pre><code>    //分页查询数据    Page&lt;User&gt; page = new Page&lt;&gt;(pn,2);    //分页查询结果    Page&lt;User&gt; userPage = userService.page(page, null);    model.addAttribute(&quot;page&quot;,userPage);    return &quot;data_tables/dynamic_table&quot;;&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- html页面（利用thymeleaf模板引擎）</span><br><span class="line"></span><br><span class="line">  - 传入page，page.records表示总分页数据</span><br><span class="line"></span><br><span class="line">  - 遍历加状态写法：th:each=&quot;user,status:$&#123;page.records&#125;&quot;，user表示每个遍历出来的用户，status表示状态</span><br><span class="line"></span><br><span class="line">  - 页面转发并携带参数写法：th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot; th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;</span><br><span class="line"></span><br><span class="line">  - 条件判断：th:if  th:switch</span><br><span class="line"></span><br><span class="line">  - 生成数字序列：#numbers.sequence(1,page.pages)，从一到末页</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">                    &lt;th&gt;#&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;邮箱&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">    </span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;page.records&#125;&quot;&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;Trident&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;Internet&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;Internet</span><br><span class="line">                            Explorer 4.0&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-danger btn-sm&quot; type=&quot;button&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">            &lt;!--分页条--&gt;</span><br><span class="line">                &lt;div class=&quot;row-fluid&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;span6&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;dataTables_info&quot; id=&quot;dynamic-table_info&quot;&gt;</span><br><span class="line">                            当前第[[$&#123;page.current&#125;]]页  总计 [[$&#123;page.pages&#125;]]页  共[[$&#123;page.total&#125;]]条记录</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;span6&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt;</span><br><span class="line">                            &lt;ul&gt;    </span><br><span class="line">                                &lt;!--判断是否有上一页--&gt;</span><br><span class="line">                                &lt;li th:switch=&quot;$&#123;page.hasPrevious()&#125;&quot;&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()-1&#125;)&#125;&quot; th:case=&quot;true&quot;&gt;← 前一页&lt;/a&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()&#125;)&#125;&quot; th:case=&quot;false&quot;&gt;← 前一页&lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                                &lt;li th:class=&quot;$&#123;num == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,page.pages)&#125;&quot; &gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                                &lt;!--判断是否还有下一页--&gt;</span><br><span class="line">                                &lt;li th:switch=&quot;$&#123;page.hasNext()&#125;&quot;&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()+1&#125;)&#125;&quot; th:case=&quot;true&quot;&gt;下一页 → &lt;/a&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()&#125;)&#125;&quot; th:case=&quot;false&quot;&gt;下一页 → &lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; &amp;emsp;&amp;emsp;MyBatis-Plus（简称 MP）是一个Mybatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。刚好最近学到springboot，来实现一个简单的整合。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="springboot" scheme="http://example.com/tags/springboot/"/>
    
    <category term="mybatis" scheme="http://example.com/tags/mybatis/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>利用Hexo搭建个人博客</title>
    <link href="http://example.com/article/4b8dd3b5.html"/>
    <id>http://example.com/article/4b8dd3b5.html</id>
    <published>2021-08-03T04:52:45.000Z</published>
    <updated>2021-08-11T10:21:42.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;搭建个人博客是一直想要做的事情，刚好在B站上面看到了相关视频，趁此机会好好搭建自己的博客，同时记录一下自己的学习经历。</p><span id="more"></span><h1 id="博客框架选择"><a href="#博客框架选择" class="headerlink" title="博客框架选择"></a>博客框架选择</h1><p>&emsp;&emsp;该博客采用的是静态博客的搭建方式，区别于动态博客，静态博客没有后台管理，管理起来相对没有那么方便。好处是搭建方便，上手快，一两天就可以搭建完成。本篇文章主要介绍如何在<strong>Windows系统</strong>下搭建。</p><p>&emsp;&emsp;网上有许多博客搭建框架，我这个博客采用的是<a href="https://hexo.io/zh-cn/">hexo</a>框架，使用人数多，各种主题，网上的教程也比较丰富，出现问题网上解决方法多。其他博客有框架：<strong>Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll</strong>。</p><h1 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h1><ul><li><p>安装<a href="http://git-scm.com/">Git</a></p><ul><li>安装成功，鼠标右键可以看到相关git bash</li></ul></li><li><p>需要一个<a href="https://github.com/">GitHub</a>账号或者gitee</p><ul><li>将本机的git与github绑定</li><li>参考：<a href="https://zhuanlan.zhihu.com/p/103391101">https://zhuanlan.zhihu.com/p/103391101</a></li></ul></li><li><p>安装<a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p><ul><li><p>hexo基于node.js</p></li><li><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低兼容 Node.js 版本</th></tr></thead><tbody><tr><td align="left">5.0+</td><td align="left">10.13.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td></tr><tr><td align="left">3.3 - 3.9</td><td align="left">6.9</td></tr><tr><td align="left">3.2 - 3.3</td><td align="left">0.12</td></tr><tr><td align="left">3.0 - 3.1</td><td align="left">0.10 or iojs</td></tr><tr><td align="left">0.0.1 - 2.8</td><td align="left">0.10</td></tr></tbody></table></li><li><p>windows用户使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p></li><li><p>安装完成之后，win+r，输入命令查看安装版本，判断是否安装成功</p><p><img src="/article/4b8dd3b5/image-20210803143849473.png" alt="查看安装版本"></p></li></ul></li></ul><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>&emsp;&emsp;在完成了上面的准备工作之后，就可以开始正式安装hexo框架了。下面的命令本人都是在win+R命令行下输入操作的，当然也可以在git bash下完成，看个人习惯即可。</p><blockquote><p>hexo的安装及后续插件的安装，都是使用npm来进行安装</p></blockquote><ol><li><p>输入安装hexo命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>初始化hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">注：&lt;folder&gt;表示你将要新建的博客在本地的文件夹位置，比如 D:\Blog</span><br><span class="line">   该文件夹必须为空</span><br></pre></td></tr></table></figure></li><li><p>安装完之后，文件夹一般有以下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  #配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source  #资源目录，你的博客就在这里，还有一些图片也可能会放在这里</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes  #主题目录，里面放你需要的主题，可以根据自己需要更换</span><br></pre></td></tr></table></figure></li><li><p>查看静态部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">注：输入这两条命令之后，打开浏览器输入localhost:4000即可看到静态部署的页面</span><br></pre></td></tr></table></figure><p><img src="https://img2.baidu.com/it/u=3385728479,3659911900&fm=15&fmt=auto&gp=0.jpg" alt="默认主题"></p></li></ol><h1 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h1><ol><li><p>初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br><span class="line"></span><br><span class="line">注：新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</span><br></pre></td></tr></table></figure></li><li><p>新建文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line">注：[layout]具体就是博客需要放在source目录下的哪个文件夹，默认_post</span><br><span class="line">   新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。</span><br><span class="line">   如果标题包含空格的话，请使用引号括起来。</span><br></pre></td></tr></table></figure></li><li><p>新建页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br><span class="line"></span><br><span class="line">注： 不指定--path,Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。</span><br><span class="line">除了--path，还有下面的可选参数（新建文章也适用）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table></li><li><p>网站部署</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr><tr><td align="left"><code>-g</code>,<code>--generate</code></td><td align="left">生成静态文件</td></tr></tbody></table><blockquote><p>一般修改完网站的配置等信息之后，<strong>使用<code>hexo g</code>和<code>hexo d</code>即可更新网站</strong>。不行的话，最前面<strong>再加上<code>hexo cl</code></strong></p></blockquote></li><li><p>静态部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"></span><br><span class="line">注： 启动本地服务器，访问网址为： http://localhost:4000/</span><br><span class="line">简写为`hexo s`</span><br><span class="line">一般可以在线看修改的效果，不用重新启动，样式变化也会随之变化</span><br></pre></td></tr></table></figure></li><li><p>清除缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">注： 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">当发现重新部署无效时，可以使用该命令。</span><br></pre></td></tr></table></figure></li><li><p>其他命令</p><blockquote><p>命令在<a href="https://hexo.io/zh-cn/docs/commands">官方文档</a>都有详细介绍，本文暂将用到的列出如上。</p><p>一般命令都可以缩写前面一两个字母即可，比如<code>hexo cl</code>清除缓存。</p></blockquote></li></ol><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><blockquote><p>Hexo提供了许多可供选择的主题，可在<a href="https://hexo.io/themes/">官方文档</a>选择自己喜欢的主题样式。</p></blockquote><p>下面介绍更换主题的步骤（以<a href="https://github.com/theme-next/hexo-theme-next">next主题</a>为例）：</p><ol><li><p>选择自己喜欢的主题之后，将其GitHub仓库clone到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">注： 如果clone过慢可以尝试直接下载到本地，然后解压到themes目录下面，并将文件夹改名为主题名</span><br></pre></td></tr></table></figure></li><li><p>修改博客目录下的配置文件</p><p>直接查找<code>themes</code>，把默认的主题替换成你主题的名字</p></li><li><p>重新部署网站</p></li></ol><h1 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h1><p>&emsp;&emsp;在完成上面的步骤之后，你的博客还是只能在自己电脑上通过<code>http://localhost:4000/</code>访问。想分享给别人看就需要通过部署域名来实现，或者也可以通过GitHub（gitee)来实现。这里介绍怎么部署到GitHub上面。</p><ol><li><p>首先，你需要新建一个仓库</p><p><img src="/article/4b8dd3b5/image-20210803155904543.png" alt="新建仓库"></p><p>仓库名你自己的GitHub名字.github.io即可，比如我的仓库名<code>a-cipher.github.io</code></p><p>仓库地址就是你这个仓库的网址，比如我的<code>https://github.com/a-cipher/a-cipher.github.io.git</code></p></li><li><p>修改配置文件</p><p>划到最下面，或者直接搜索<code>repository</code>,在后面加上你的仓库地址即可</p><p><img src="/article/4b8dd3b5/image-20210803160502744.png" alt="修改配置文件"></p></li><li><p>安装git部署插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后三部曲，重新部署。输入 <a href="https://fengye97.github.io/">https://xxx.github.io</a> 就可以打开你的网页了：</p></li></ol><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><blockquote><p>整个博客的搭建花了一两天的时间，记录自己遇到的问题</p></blockquote><ul><li><p>一般在更换主题之后，都要进行自定义的配置修改，基本修改都在_config.yml里面进行修改。</p><p>注意区分：博客目录下面有一个_config.yml，你的主题下面还有一个 _config.yml。</p></li><li><p>配置文件都是yml文件，需要按照yaml语法来进行编写。比如：<code>theme: next</code>，冒号后面有一个空格，给一个变量赋多个值的写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tags:</span> [<span class="string">标签1</span>,<span class="string">标签2</span>,<span class="string">标签3</span>]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">标签2</span></span><br></pre></td></tr></table></figure><p>如果命令行报错指向你具体的哪一行，很可能就是语法错误。</p></li><li><p>部署的时候如果报错有<code>connection</code> <code>ssl</code>这种字眼，大多情况可能是网络连接有错误，可以考虑用<code>tizhi</code></p></li><li><p>由于hexo博客的编写采用的是markdown语法，编写博客可以考虑使用markdown编辑器来辅助编写，比如Typora。</p><p>提供一种输入<code>hexo n</code>就自动打开本地编辑器的办法：</p><p>在博客目录下面新建一个scripts目录，里面加上一个js文件，文件名自取，内容如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).exec;</span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">&#x27;start  &quot;D:\Program Files\Typora\Typora.exe&quot; &#x27;</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>markdown语法实现缩进<code>&amp;emsp;&amp;emsp;</code></p></li><li><p>在搭建博客如果出现问题，大不了把文件全删了重头再来，多试几次就好了。</p></li><li><p>无论是博客的搭建还是修改主题的样式，官方文档都是好帮手，如果还是解决不了百度即可。</p></li><li><p>next主题更新之后，原来的custom.styl已经取消，样式修改可以在source目录新建一个<code>Blog\source\_data\styles.styl</code></p><p>注意需要将主题配置文件中对应地方取消注释</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li><li><p>博客中图片的访问方式</p><ol><li><p>网络图片直接复制插入即可。</p></li><li><p>本地图片默认访问规则</p><p>图片统一将它们放在博客目录下 <code>source/images</code> 文件夹中。然后通过 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><p>也可通过<code>&lt;img src=&quot;/images/image.jpg&quot;&gt;</code>访问，这种可以改变样式。</p></li><li><p>本地图片，相对路径</p><ol><li><p>开启站点配置文件 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 在配置文件加上以下，可以用&#123;% asset_img %&#125;方式</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>md文件创建时会自动创建同名文件夹，把图片放在该目录下面</p></li><li><p>访问的时候<code>![图片标题](图片名.jpg)</code></p><p>或者使用<code>&#123;% asset_img 图片名.png 宽 高 标题 %&#125;</code>，宽高标题可以不写</p></li></ol></li></ol></li><li><p>······</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><p><a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></p><p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;搭建个人博客是一直想要做的事情，刚好在B站上面看到了相关视频，趁此机会好好搭建自己的博客，同时记录一下自己的学习经历。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="经验分享" scheme="http://example.com/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
</feed>
