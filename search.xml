<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis-Plus代码生成</title>
    <url>/article/7cc9a691.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;MyBatis-Plus某种程度上属于MyBatis的升级版，在许多方面都使我们的开发更加简便。这篇文章介绍在SpringBoot中怎么使用MyBatis的代码生成器。AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<span id="more"></span>

<h1 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h1><p>&emsp;&emsp;我们可以创建一个SpringBoot项目<code>CodeGenerator</code>专门用于生成我们的MyBatis_plus代码，每次有新项目都可以通过这个项目来生成我们需要的实体类，Mapper等代码。</p>
<p>项目创建完成之后，需要引入相应的依赖，具体依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web场景--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--MySQL数据库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Mybatis-Plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--代码生成器依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>Lombok是一个插件，可以通过注解免去生成get，set等方法</li>
<li>数据源可以根据自己需要更换，这里使用的是Druid</li>
<li>MyBatis-Plus 从 <code>3.0.3</code> 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖</li>
<li>模板引擎有多种，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎</li>
</ul>
<h1 id="添加代码生成类"><a href="#添加代码生成类" class="headerlink" title="添加代码生成类"></a>添加代码生成类</h1><p>在<code>CodeGenerator\src\main\java\com\example\codegenerator\</code>目录下添加代码生成类。</p>
<p>主要需要修改的部分如下</p>
<ol>
<li><p>全局配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>); <span class="comment">//生成路径</span></span><br><span class="line">gc.setAuthor(<span class="string">&quot;作者名字&quot;</span>);</span><br><span class="line">gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">mpg.setGlobalConfig(gc);</span><br></pre></td></tr></table></figure></li>
<li><p>数据源配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line"><span class="comment">//数据库地址，把student更换成你的数据库名即可</span></span><br><span class="line">dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/student?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);</span><br><span class="line">dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="comment">//数据库类型</span></span><br><span class="line">dsc.setUsername(<span class="string">&quot;数据库用户名&quot;</span>);</span><br><span class="line">dsc.setPassword(<span class="string">&quot;数据库密码&quot;</span>);</span><br><span class="line">mpg.setDataSource(dsc);</span><br></pre></td></tr></table></figure></li>
<li><p>包配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">pc.setModuleName(scanner(<span class="string">&quot;模块名&quot;</span>));</span><br><span class="line">pc.setParent(<span class="string">&quot;com.example.codegenerator&quot;</span>); <span class="comment">//代码生成的文件目录，不存在则会新建</span></span><br><span class="line">mpg.setPackageInfo(pc);</span><br></pre></td></tr></table></figure></li>
<li><p>更改模板引擎</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果模板引擎是 freemarker</span></span><br><span class="line"><span class="comment">// String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span></span><br><span class="line"><span class="comment">// 如果模板引擎是 velocity</span></span><br><span class="line">String templatePath = <span class="string">&quot;/templates/mapper.xml.vm&quot;</span>;</span><br><span class="line"><span class="comment">//其他模板引擎同理</span></span><br></pre></td></tr></table></figure></li>
<li><p>策略配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line"><span class="comment">//        strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span></span><br><span class="line">strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 公共父类</span></span><br><span class="line"><span class="comment">// strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span></span><br><span class="line"><span class="comment">// 写于父类中的公共字段</span></span><br><span class="line">strategy.setSuperEntityColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">strategy.setInclude(scanner(<span class="string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line">strategy.setTablePrefix(pc.getModuleName() + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">mpg.setStrategy(strategy);</span><br><span class="line"><span class="comment">// mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span></span><br><span class="line">mpg.setTemplateEngine(<span class="keyword">new</span> VelocityTemplateEngine()); <span class="comment">//根据你的模板引擎更改</span></span><br><span class="line">mpg.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>支持自定义配置</p>
<p>自定义配置优先！</p>
</li>
<li><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 读取控制台内容</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scanner</span><span class="params">(String tip)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        StringBuilder help = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        help.append(<span class="string">&quot;请输入&quot;</span> + tip + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MybatisPlusException(<span class="string">&quot;请输入正确的&quot;</span> + tip + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// gc.setSwagger2(true); 实体属性 Swagger2 注解</span></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/student?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);</span><br><span class="line">        <span class="comment">// dsc.setSchemaName(&quot;public&quot;);</span></span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(scanner(<span class="string">&quot;模块名&quot;</span>));</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.example.codegenerator&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义配置</span></span><br><span class="line">        InjectionConfig cfg = <span class="keyword">new</span> InjectionConfig() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// to do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果模板引擎是 freemarker</span></span><br><span class="line"><span class="comment">//        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span></span><br><span class="line">        <span class="comment">// 如果模板引擎是 velocity</span></span><br><span class="line">        String templatePath = <span class="string">&quot;/templates/mapper.xml.vm&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义输出配置</span></span><br><span class="line">        List&lt;FileOutConfig&gt; focList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义配置会被优先输出</span></span><br><span class="line">        focList.add(<span class="keyword">new</span> FileOutConfig(templatePath) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">outputFile</span><span class="params">(TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span></span><br><span class="line">                <span class="keyword">return</span> projectPath + <span class="string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()</span><br><span class="line">                        + <span class="string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cfg.setFileCreate(new IFileCreate() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span></span><br><span class="line"><span class="comment">                // 判断自定义文件夹是否需要创建</span></span><br><span class="line"><span class="comment">                checkDir(&quot;调用默认方法创建的目录，自定义目录用&quot;);</span></span><br><span class="line"><span class="comment">                if (fileType == FileType.MAPPER) &#123;</span></span><br><span class="line"><span class="comment">                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false</span></span><br><span class="line"><span class="comment">                    return !new File(filePath).exists();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                // 允许生成模板文件</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        mpg.setCfg(cfg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置模板</span></span><br><span class="line">        TemplateConfig templateConfig = <span class="keyword">new</span> TemplateConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置自定义输出模板</span></span><br><span class="line">        <span class="comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span></span><br><span class="line">        <span class="comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span></span><br><span class="line">        <span class="comment">// templateConfig.setService();</span></span><br><span class="line">        <span class="comment">// templateConfig.setController();</span></span><br><span class="line"></span><br><span class="line">        templateConfig.setXml(<span class="keyword">null</span>);</span><br><span class="line">        mpg.setTemplate(templateConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line"><span class="comment">//        strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 公共父类</span></span><br><span class="line"><span class="comment">//        strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span></span><br><span class="line">        <span class="comment">// 写于父类中的公共字段</span></span><br><span class="line">        strategy.setSuperEntityColumns(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        strategy.setInclude(scanner(<span class="string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setTablePrefix(pc.getModuleName() + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"><span class="comment">//        mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span></span><br><span class="line">        mpg.setTemplateEngine(<span class="keyword">new</span> VelocityTemplateEngine());</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更详细的配置修改可参见<a href="https://mp.baomidou.com/config/generator-config.html#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">官网</a></p>
</li>
</ol>
<h1 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h1><p>&emsp;&emsp;点击运行上述<code>codegenerator</code>输入生成的文件目录，再输入需要生成的表，多个表之间用英文逗号隔开，回车即可自动生成相应的代码，如下：</p>
<p><img src="/article/7cc9a691/image-20210805162503596.png" alt="生成目录"></p>
<p>同时生成的代码会根据你数据库表的注释生成相应的注释</p>
<p><img src="/article/7cc9a691/image-20210805162732055.png" alt="生成的实体类"></p>
<p>注：mysql数据库注释使用<code>comment</code>，可在建表时注释，也可后续添加</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.baomidou.com/guide/generator.html#">https://mp.baomidou.com/guide/generator.html#</a></p>
<p><a href="https://mp.baomidou.com/config/generator-config.html#">https://mp.baomidou.com/config/generator-config.html#</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus整合SpringBoot</title>
    <url>/article/a09c4a7b.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> &emsp;&emsp;MyBatis-Plus（简称 MP）是一个Mybatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。刚好最近学到springboot，来实现一个简单的整合。</p>
<span id="more"></span>

<h1 id="快速实现"><a href="#快速实现" class="headerlink" title="快速实现"></a>快速实现</h1><ol>
<li><p>官方介绍：<a href="https://mp.baomidou.com/guide">https://mp.baomidou.com/guide</a></p>
<p>gitee源码地址：<a href="https://gitee.com/baomidou/mybatis-plus">https://gitee.com/baomidou/mybatis-plus</a></p>
</li>
<li><p>快速实现</p>
<ul>
<li><p>导入依赖</p>
<ul>
<li><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>编写配置类，默认已经配置好了不少</p>
<ul>
<li>注：<strong>使用mybatis-plus之后，原先配置的mybatis会失效，需要重新在mybatis-plus配置</strong></li>
</ul>
</li>
<li><p>编写实体类</p>
<ul>
<li>```Java<br>//该注解可以表明该字段不在数据库，否则mybatis-plus使用报错<br>@TableField(exist = false)<br>private String userName;<br>@TableField(exist = false)<br>private String password;//@TableName(“user_tbl”),默认根据类名获取数据库中的表名，当名字不一致，可以使用该注解指定数据库表<br>//@TableName(“user_tbl”)注解加在类前面<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 编写mapper类</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //BaseMapper里面包括了基本的CRUD方法，我们不用额外再写</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试输出</p>
<pre><code>@Autowired
private UserMapper userMapper;
@Test
public void testSelect() &#123;
    System.out.println((&quot;----- selectAll method test ------&quot;));
    List&lt;User&gt; userList = userMapper.selectList(null);
    Assert.assertEquals(5, userList.size());
    userList.forEach(System.out::println);
&#125;
</code></pre>
</li>
<li><p>具体可参照官方文档</p>
</li>
</ul>
</li>
</ol>
<h1 id="CRUD功能的实现"><a href="#CRUD功能的实现" class="headerlink" title="CRUD功能的实现"></a>CRUD功能的实现</h1><ul>
<li><p>在上一部分的基础上进行</p>
</li>
<li><p>暂时只实现了删除</p>
</li>
<li><p>service层 Userservice 继承IService<User></p>
<ul>
<li>```java<br>public interface UserService extends IService<User> {<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实现service接口</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    @Service</span><br><span class="line">    public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>控制层实现数据的展示和数据删除</p>
<ul>
<li><p>RedirectAttributes重定向之后可以携带参数</p>
</li>
<li><p>```Java</p>
<pre><code>@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)
public String deleteUser(@PathVariable(&quot;id&quot;) Integer id,
                         @RequestParam(&quot;pn&quot;) Integer pn,
                         RedirectAttributes rn)&#123;

    userService.removeById(id);
    rn.addAttribute(pn);
    return &quot;redirect:/dynamic_table&quot;;
&#125;

@GetMapping(&quot;/dynamic_table&quot;)
public String dynamic_table(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn, Model model)&#123;
    
    List&lt;User&gt; list = userService.list();
</code></pre>
<p>//        model.addAttribute(“list”,list);</p>
<pre><code>    //分页查询数据
    Page&lt;User&gt; page = new Page&lt;&gt;(pn,2);

    //分页查询结果
    Page&lt;User&gt; userPage = userService.page(page, null);
    model.addAttribute(&quot;page&quot;,userPage);
    return &quot;data_tables/dynamic_table&quot;;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- html页面（利用thymeleaf模板引擎）</span><br><span class="line"></span><br><span class="line">  - 传入page，page.records表示总分页数据</span><br><span class="line"></span><br><span class="line">  - 遍历加状态写法：th:each=&quot;user,status:$&#123;page.records&#125;&quot;，user表示每个遍历出来的用户，status表示状态</span><br><span class="line"></span><br><span class="line">  - 页面转发并携带参数写法：th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot; th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;</span><br><span class="line"></span><br><span class="line">  - 条件判断：th:if  th:switch</span><br><span class="line"></span><br><span class="line">  - 生成数字序列：#numbers.sequence(1,page.pages)，从一到末页</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">                    &lt;th&gt;#&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;邮箱&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">    </span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;page.records&#125;&quot;&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;Trident&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;Internet&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;Internet</span><br><span class="line">                            Explorer 4.0&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-danger btn-sm&quot; type=&quot;button&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">            &lt;!--分页条--&gt;</span><br><span class="line">                &lt;div class=&quot;row-fluid&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;span6&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;dataTables_info&quot; id=&quot;dynamic-table_info&quot;&gt;</span><br><span class="line">                            当前第[[$&#123;page.current&#125;]]页  总计 [[$&#123;page.pages&#125;]]页  共[[$&#123;page.total&#125;]]条记录</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;span6&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt;</span><br><span class="line">                            &lt;ul&gt;    </span><br><span class="line">                                &lt;!--判断是否有上一页--&gt;</span><br><span class="line">                                &lt;li th:switch=&quot;$&#123;page.hasPrevious()&#125;&quot;&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()-1&#125;)&#125;&quot; th:case=&quot;true&quot;&gt;← 前一页&lt;/a&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()&#125;)&#125;&quot; th:case=&quot;false&quot;&gt;← 前一页&lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                                &lt;li th:class=&quot;$&#123;num == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,page.pages)&#125;&quot; &gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                                &lt;!--判断是否还有下一页--&gt;</span><br><span class="line">                                &lt;li th:switch=&quot;$&#123;page.hasNext()&#125;&quot;&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()+1&#125;)&#125;&quot; th:case=&quot;true&quot;&gt;下一页 → &lt;/a&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()&#125;)&#125;&quot; th:case=&quot;false&quot;&gt;下一页 → &lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记1</title>
    <url>/article/17173e24.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;之前学的springboot笔记，放上来方便查看</p>
<span id="more"></span>
<h1 id="SpringBoot-2"><a href="#SpringBoot-2" class="headerlink" title="SpringBoot 2"></a>SpringBoot 2</h1><h2 id="1-入门基础"><a href="#1-入门基础" class="headerlink" title="1.入门基础"></a>1.入门基础</h2><p><strong>雷丰阳老师语雀地址：<a href="https://www.yuque.com/atguigu/springboot">https://www.yuque.com/atguigu/springboot</a></strong></p>
<ol>
<li>需要掌握</li>
</ol>
<ul>
<li>熟悉Spring基础</li>
<li>熟悉Maven使用</li>
</ul>
<ol start="2">
<li>环境要求</li>
</ol>
<ul>
<li>Java8及以上    通过命令java -version</li>
<li>Maven 3.3及以上      命令mvn -v</li>
<li>文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements</a></li>
</ul>
<h2 id="2-spring与springboot"><a href="#2-spring与springboot" class="headerlink" title="2.spring与springboot"></a>2.spring与springboot</h2><h3 id="2-1-基本区别"><a href="#2-1-基本区别" class="headerlink" title="2.1 基本区别"></a>2.1 <strong>基本区别</strong></h3><ul>
<li>宏观上的spring包括整个spring生态圈<ul>
<li>web开发</li>
<li>数据访问</li>
<li>安全控制</li>
<li>分布式</li>
<li>消息服务</li>
<li>移动开发</li>
<li>批处理</li>
</ul>
</li>
<li>微观上的spring仅仅指spring framework</li>
<li>spring底层是Java</li>
<li>springboot底层是spring</li>
</ul>
<h3 id="2-2-spring5的重大升级"><a href="#2-2-spring5的重大升级" class="headerlink" title="2.2 spring5的重大升级"></a>2.2 <strong>spring5的重大升级</strong></h3><ul>
<li>增加了响应式编程 reactive stack</li>
<li>内部源码设计<ul>
<li>基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。</li>
<li>接口默认实现需要关键字default，对于该方法提供了空实现</li>
</ul>
</li>
</ul>
<h3 id="2-3-springboot优缺点"><a href="#2-3-springboot优缺点" class="headerlink" title="2.3 springboot优缺点"></a>2.3 <strong>springboot优缺点</strong></h3><ul>
<li>优点<ul>
<li>Create stand-alone Spring applications</li>
<li>创建独立Spring应用</li>
<li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</li>
<li>内嵌web服务器</li>
<li>Provide opinionated ‘starter’ dependencies to simplify your build configuration</li>
<li>自动starter依赖，简化构建配置</li>
<li>Automatically configure Spring and 3rd party libraries whenever possible</li>
<li>自动配置Spring以及第三方功能</li>
<li>Provide production-ready features such as metrics, health checks, and externalized configuration</li>
<li>提供生产级别的监控、健康检查及外部化配置</li>
<li>Absolutely no code generation and no requirement for XML configuration</li>
<li>无代码生成、无需编写XML</li>
</ul>
</li>
</ul>
<p>​    <em><strong>SpringBoot是整合Spring技术栈的一站式框架</strong></em></p>
<p>​    <em><strong>SpringBoot是简化Spring技术栈的快速开发脚手架</strong></em></p>
<ul>
<li>缺点<ul>
<li>人称版本帝，迭代快，需要时刻关注变化</li>
<li>封装太深，内部原理复杂，不容易精通</li>
</ul>
</li>
</ul>
<h2 id="3-第一个springboot程序"><a href="#3-第一个springboot程序" class="headerlink" title="3.第一个springboot程序"></a>3.第一个springboot程序</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application</a></p>
<ol>
<li><p>配置pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写主程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 主程序类</span></span><br><span class="line"><span class="comment">* @SpringBootApplication：这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Main.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：官网用的，把上述两个文件写在一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行程序，直接在浏览器输入地址即可</p>
</li>
<li><p>配置文件统一写在application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改默认端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure></li>
<li><p>快捷生成可执行的jar</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>![image-20210711170405448](SpringBoot 2-01.assets/image-20210711170405448.png)</p>
</li>
</ol>
<p>![image-20210711170440942](SpringBoot 2-01.assets/image-20210711170440942.png)</p>
<p>​            执行命令：jar包目录下  java -jar jar包名.jar</p>
<h2 id="4-springboot特点"><a href="#4-springboot特点" class="headerlink" title="4.springboot特点"></a>4.springboot特点</h2><ol>
<li><p>依赖管理</p>
<ul>
<li>父项目做依赖管理</li>
<li>开发导入starter场景启动器</li>
<li>无需关注版本号，自动版本仲裁</li>
<li>可以<strong>修改默认版本号</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">2、在当前项目里面重写配置</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>自动配置</p>
<ul>
<li><p>自动配好Tomcat</p>
</li>
<li><p>自动配好SpringMVC</p>
</li>
<li><p>自动配好Web常见功能，如：字符编码问题</p>
</li>
<li><p>默认的包结构</p>
<ul>
<li><p><strong>主程序所在包及其下面的所有子包</strong>里面的组件都会被默认扫描进来</p>
</li>
<li><p>无需以前的包扫描配置</p>
</li>
<li><p>想要改变扫描路径，@SpringBootApplication(scanBasePackages=<strong>“com.atguigu”</strong>)</p>
</li>
<li><p>或者@ComponentScan 指定扫描路径</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">等同于</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(&quot;com.atguigu.boot&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>各种配置拥有默认值</p>
</li>
<li><p>按需加载所有自动配置项</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-容器功能"><a href="#5-容器功能" class="headerlink" title="5.容器功能"></a>5.容器功能</h2><h3 id="5-1-组件添加"><a href="#5-1-组件添加" class="headerlink" title="5.1 组件添加"></a>5.1 组件添加</h3><ol>
<li><h6 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h6><ul>
<li>基本使用</li>
<li>@Configuration(proxyBeanMethods = true)<strong>Full模式与Lite模式</strong><ul>
<li>配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断，false</li>
<li>配置类组件之间<strong>有依赖关系</strong>，方法会被调用得到<strong>之前单实例组件</strong>，用Full模式，默认true</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="Bean、-Component、-Controller、-Service、-Repository"><a href="#Bean、-Component、-Controller、-Service、-Repository" class="headerlink" title="@Bean、@Component、@Controller、@Service、@Repository"></a>@Bean、@Component、@Controller、@Service、@Repository</h6><p>和之前spring中的注解一样</p>
</li>
<li><h6 id="ComponentScan、-Import"><a href="#ComponentScan、-Import" class="headerlink" title="@ComponentScan、@Import"></a>@ComponentScan、@Import</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * <span class="number">4</span>、<span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"> *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h6 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h6><p>条件装配：满足Conditional指定的条件，则进行组件注入</p>
</li>
</ol>
<h3 id="5-2-原生配置文件引入"><a href="#5-2-原生配置文件引入" class="headerlink" title="5.2 原生配置文件引入"></a>5.2 原生配置文件引入</h3><ol>
<li><p>@ImportResource</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@ImportResource(&quot;classpath:beans.xml&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-3-配置绑定"><a href="#5-3-配置绑定" class="headerlink" title="5.3 配置绑定"></a>5.3 配置绑定</h3><ol>
<li><p>@Component + @ConfigurationProperties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">mycar.carName</span>=<span class="string">byd</span></span><br><span class="line"><span class="meta">mycar.carPrice</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure></li>
<li><p>@EnableConfigurationProperties + @ConfigurationProperties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="comment">//1、开启Car配置绑定功能</span></span><br><span class="line"><span class="comment">//2、把这个Car这个组件自动注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-自动装配原理"><a href="#6-自动装配原理" class="headerlink" title="6.自动装配原理"></a>6.自动装配原理</h2><h3 id="6-1-引导加载自动配置类"><a href="#6-1-引导加载自动配置类" class="headerlink" title="6.1 引导加载自动配置类"></a>6.1 引导加载自动配置类</h3><ul>
<li><p>@SpringBootApplication表示这是一个springboot应用，里面包括</p>
</li>
<li><p>```Java<br>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan(</p>
<pre><code>excludeFilters = &#123;@Filter(
type = FilterType.CUSTOM,
classes = &#123;TypeExcludeFilter.class&#125;
</code></pre>
<p>), @Filter(</p>
<pre><code>type = FilterType.CUSTOM,
classes = &#123;AutoConfigurationExcludeFilter.class&#125;
</code></pre>
<p>)}<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. @SpringBootConfiguration</span><br><span class="line"></span><br><span class="line">   表示当前是一个配置类@Configuration</span><br><span class="line"></span><br><span class="line">2. @ComponentScan</span><br><span class="line"></span><br><span class="line">   指定扫描</span><br><span class="line"></span><br><span class="line">3. @EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">   ```Java</span><br><span class="line">   @AutoConfigurationPackage</span><br><span class="line">   @Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@AutoConfigurationPackage自动配置包，其中包含了默认的包规则</p>
</li>
<li><p>~~~java<br>@Import(AutoConfigurationPackages.Registrar.class)  //给容器中导入一个组件<br>public @interface AutoConfigurationPackage {}</p>
<p>//利用Registrar给容器中导入一系列组件<br>//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- @Import(AutoConfigurationImportSelector.class)</span><br><span class="line"></span><br><span class="line">- ~~~Java</span><br><span class="line">  1、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</span><br><span class="line">  2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</span><br><span class="line">  3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件</span><br><span class="line">  4、从META-INF/spring.factories位置来加载一个文件。</span><br><span class="line">  	默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件</span><br><span class="line">      spring-boot-autoconfigure-2.5.2.RELEASE.jar包里面也有META-INF/spring.factories</span><br><span class="line">      一共131</span><br></pre></td></tr></table></figure>

<p>![image-20210712174901262](SpringBoot 2-01.assets/image-20210712174901262.png)</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-按需开启自动配置"><a href="#6-2-按需开启自动配置" class="headerlink" title="6.2 按需开启自动配置"></a>6.2 按需开启自动配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">虽然我们<span class="number">127</span>个（<span class="number">2.5</span><span class="number">.2</span>一共<span class="number">131</span>个）场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration</span><br><span class="line">按照条件装配规则（<span class="meta">@Conditional</span>），最终会按需配置。</span><br></pre></td></tr></table></figure>

<h3 id="6-3-修改默认配置"><a href="#6-3-修改默认配置" class="headerlink" title="6.3 修改默认配置"></a>6.3 修改默认配置</h3><p>springboot底层已经配置好了所有了组件，用户配置了的话则以配置的优先</p>
<p>因为里面都有条件装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnBean(MultipartResolver.class)</span>  <span class="comment">//容器中有这个类型组件</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span> <span class="comment">//容器中没有这个名字 multipartResolver 的组件</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</span></span><br><span class="line">            <span class="comment">//SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范</span></span><br><span class="line">			<span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line">			<span class="keyword">return</span> resolver;</span><br><span class="line">		&#125;</span><br><span class="line">给容器中加入了文件上传解析器；</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</p>
</li>
<li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</p>
</li>
<li><p>生效的配置类就会给容器中装配很多组件</p>
</li>
<li><p>只要容器中有这些组件，相当于这些功能就有了</p>
</li>
<li><p>定制化配置</p>
</li>
<li><p>用户直接自己@Bean替换底层的组件</p>
</li>
<li><p>用户去看这个组件是获取的配置文件什么值就去修改。</p>
</li>
</ul>
<p><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt;</strong> <strong>xxxxProperties里面拿值  —-&gt; application.properties</strong></p>
<p>同时需要修改某些默认的配置</p>
<h3 id="6-4-最佳实践"><a href="#6-4-最佳实践" class="headerlink" title="6.4 最佳实践"></a>6.4 最佳实践</h3><ul>
<li><p>引入场景依赖</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a></li>
</ul>
</li>
<li><p>查看自动配置了哪些（选做）</p>
<ul>
<li>自己分析，引入场景对应的自动配置一般都生效了</li>
<li>配置文件中添加debug=true开启自动配置报告。Negative（不生效）\Positive（生效）</li>
</ul>
</li>
<li><p>是否需要修改</p>
<ul>
<li>参照文档修改配置项<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties</a></li>
<li>spring.banner.image.location可以修改默认的spring图案</li>
</ul>
</li>
<li>自己分析。xxxxProperties绑定了配置文件的哪些。<ul>
<li>查看源码，一般在spring-boot-autoconfigure-2.5.2.jar需要哪个一步一步查看源码即可</li>
</ul>
</li>
<li>自定义加入或者替换组件</li>
<li>@Bean、@Component。。。</li>
<li>自定义器  <strong>XXXXXCustomizer</strong>；</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="7-开发技巧"><a href="#7-开发技巧" class="headerlink" title="7.开发技巧"></a>7.开发技巧</h2><h3 id="7-1-Lombok"><a href="#7-1-Lombok" class="headerlink" title="7.1 Lombok"></a>7.1 Lombok</h3><ul>
<li>主要是不用额外写getter，setter等方法</li>
<li>实际使用看公司需求</li>
</ul>
<h3 id="7-2-热部署"><a href="#7-2-热部署" class="headerlink" title="7.2 热部署"></a>7.2 热部署</h3><ol>
<li><p>devtools</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>项目或者页面修改以后：Ctrl+F9；</li>
<li>只适合springboot</li>
</ul>
</li>
<li><p> jrebel</p>
</li>
</ol>
<p>   使用教程：<a href="https://blog.csdn.net/lianghecai52171314/article/details/105637251">https://blog.csdn.net/lianghecai52171314/article/details/105637251</a></p>
<ul>
<li>适合所有Java代码</li>
<li>收费</li>
<li>安装路径不允许有中文，解决<a href="https://blog.csdn.net/sweet_chu/article/details/102838558">https://blog.csdn.net/sweet_chu/article/details/102838558</a></li>
<li>目前对于idea热部署最好的解决方案就是安装JRebel插件</li>
<li>项目或者页面修改以后：<ul>
<li>Ctrl+Shift+F9；</li>
<li>鼠标移开就可以</li>
</ul>
</li>
<li>无法生效情况<ul>
<li>重新往容器里面注入东西</li>
<li>修改resource下面的东西</li>
</ul>
</li>
</ul>
<h3 id="7-3-Spring-Initailizr（项目初始化向导）"><a href="#7-3-Spring-Initailizr（项目初始化向导）" class="headerlink" title="7.3 Spring Initailizr（项目初始化向导）"></a>7.3 Spring Initailizr（项目初始化向导）</h3><ul>
<li>选择new Spring Initailizr，选择好需要的场景依赖<ul>
<li>自动导入依赖</li>
<li>自动生成项目结构</li>
<li>自动生成主类</li>
</ul>
</li>
</ul>
<p>![image-20210713170615292](SpringBoot 2-01.assets/image-20210713170615292.png)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>九月秋招挨打记录</title>
    <url>/article/52337174.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;正值国庆，秋招也开始这么久了。从九月开学开始，正式开始秋招，多多少少也面了一些公司，大厂没啥信心，中小厂也被狠狠打击，特此记录一下面经。期待这个月的好消息。<span id="more"></span></p>
<h2 id="线上"><a href="#线上" class="headerlink" title="线上"></a>线上</h2><h3 id="1-恒生"><a href="#1-恒生" class="headerlink" title="1 恒生"></a>1 恒生</h3><ol>
<li><p>笔试</p>
<ul>
<li>SQL语句编写，索引，表连接</li>
<li>打印杨辉三角</li>
<li>打印素数</li>
</ul>
</li>
<li><p>一面</p>
<ul>
<li>你有用过spring boot说说你的理解？配置文件？</li>
<li>索引结构，B+树</li>
<li>了解哪些设计模式</li>
<li>项目有哪些亮点</li>
<li>数据库隔离级别</li>
<li>说说乐观锁，悲观锁</li>
<li>最近失败的事情</li>
<li>对你的上司有什么期望</li>
<li>你的职业规划</li>
<li>反问<ul>
<li>面试面的怎么样</li>
<li>培养方案</li>
</ul>
</li>
</ul>
</li>
<li><p>二面（挂）</p>
<ul>
<li><p>项目遇到的困难</p>
</li>
<li><p>用到断点续传吗</p>
</li>
<li><p>数据库表怎么设计的</p>
</li>
<li><p>数据库怎么优化</p>
</li>
<li><p>索引有哪些</p>
</li>
<li><p>mybatis掌握的怎么样</p>
</li>
<li><p>怎么学习算法的</p>
</li>
<li><p>hr</p>
<ul>
<li>家庭情况</li>
<li>个人规划</li>
</ul>
</li>
<li><p>反问</p>
<ul>
<li><p>面试的怎么样，让我自己评价。。</p>
</li>
<li><p>期望薪资 </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-4399"><a href="#2-4399" class="headerlink" title="2 4399"></a>2 4399</h3><ol>
<li><p>笔试（挂）</p>
<ul>
<li><p>判断是否是回文数，（栈解决）</p>
</li>
<li><p>完全背包问题，（dp)</p>
</li>
<li><p>进制转换（2的n次方式考虑位运算，其余则字符串进位一个个算）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//这里转换成16进制，每四位相与转换即可，其他进制同理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="comment">//位运算，与</span></span><br><span class="line">            <span class="keyword">int</span> val = (num &gt;&gt; (<span class="number">4</span> * i)) &amp; <span class="number">0xf</span>;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span> || val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> digit = val &lt; <span class="number">10</span> ? (<span class="keyword">char</span>) (<span class="string">&#x27;0&#x27;</span> + val) : (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + val - <span class="number">10</span>);</span><br><span class="line">                sb.append(digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="3-小红书"><a href="#3-小红书" class="headerlink" title="3 小红书"></a>3 小红书</h3><p>​    简历挂</p>
<h3 id="4-海康"><a href="#4-海康" class="headerlink" title="4 海康"></a>4 海康</h3><ol>
<li>笔试<ul>
<li>SQL</li>
<li>简单算法</li>
<li>设计模式 ，适配器还是啥去了</li>
</ul>
</li>
<li>一面（挂）<ul>
<li>使用的Java版本</li>
<li>函数式接口，lambda表达式</li>
<li>default方法默认实现</li>
<li>Stream流</li>
<li>没听清不知道</li>
<li>callable和runnable区别</li>
<li>线程池的七个参数</li>
<li>移除数组中大于十的元素，使用迭代器remove</li>
<li>数据结构，栈的实现相关</li>
<li>计网，tcp和utp区别</li>
<li>使用tcp的协议有哪些</li>
<li>http和https的区别</li>
<li>https怎么实现加密的</li>
</ul>
</li>
</ol>
<h3 id="5-微众银行"><a href="#5-微众银行" class="headerlink" title="5 微众银行"></a>5 微众银行</h3><ol>
<li>笔试<ul>
<li>已知前缀和求原序列</li>
<li>机器人消耗能量，（模拟）</li>
<li>大哥数数（Date使用）</li>
</ul>
</li>
</ol>
<h3 id="6-58同城"><a href="#6-58同城" class="headerlink" title="6 58同城"></a>6 58同城</h3><ol>
<li>笔试<ul>
<li>零钱兑换问题（dp)</li>
<li>把二维数组转换成一维数组，对去重结果进行排序</li>
<li>二维数组，路径是否可达（dfs)</li>
</ul>
</li>
</ol>
<h2 id="线下"><a href="#线下" class="headerlink" title="线下"></a>线下</h2><h3 id="1-深圳昂楷科技"><a href="#1-深圳昂楷科技" class="headerlink" title="1 深圳昂楷科技"></a>1 深圳昂楷科技</h3><ol>
<li>笔试<ul>
<li>switch不能用哪些数据类型<ul>
<li>switch可以作用于char byte short int及它们对应的包装类型，switch不可作用于long double float boolean及他们的包装类型。在 JDK1.5之后可以作用于枚举类型，在JDK1.7之后可作用于String类型。</li>
</ul>
</li>
<li>8*2 最高效率实现</li>
<li>数据脱敏<ul>
<li>数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。在涉及客户安全数据或者一些商业性敏感数据的情况下，在不违反系统规则条件下，对真实数据进行改造并提供测试使用，如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。</li>
</ul>
</li>
<li>单例模式</li>
<li>简单编程</li>
</ul>
</li>
<li>一面（挂）<ul>
<li>Java基本数据类型，及对应大小</li>
<li>说说你了解的集合</li>
<li>hashmap底层原理</li>
<li>创建线程的方式</li>
<li>说说什么是线程池</li>
<li>spring的ioc和aop</li>
<li>aop的作用</li>
<li>springmvc的流程</li>
<li>Redis</li>
<li>数据库设计，表之间怎么联系</li>
<li>mybatis你是怎么用的</li>
<li>namespace作用，映射</li>
<li>数据库的几种连接查询</li>
</ul>
</li>
</ol>
<h3 id="2-中车"><a href="#2-中车" class="headerlink" title="2 中车"></a>2 中车</h3><ol>
<li>笔试<ul>
<li>完形填空+阅读理解，麻了</li>
<li>软件工程相关知识</li>
</ul>
</li>
<li>一面（面试官非相关技术人员）<ul>
<li>性格，沟通</li>
<li>抗压</li>
<li>随便问问就没了</li>
</ul>
</li>
<li>二面<ul>
<li>简单自我介绍</li>
<li>招运维，先各地跑半年，再开发</li>
<li>溜了</li>
</ul>
</li>
</ol>
<h3 id="3-兴盛优选"><a href="#3-兴盛优选" class="headerlink" title="3 兴盛优选"></a>3 兴盛优选</h3><ol>
<li><p>笔试</p>
<ul>
<li><p>io中断和dma方式区别</p>
</li>
<li><p>LRU缓存缺页问题(页面置换算法)</p>
</li>
<li><p>栈排序问题</p>
</li>
<li><p>出现一半以上的数字</p>
</li>
<li><p>设计选课系统</p>
</li>
<li><p>3000用户设计5w人QPS，问题转换为怎么应对大流量</p>
<ul>
<li><p><strong>QPS（Query Per Second）：每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</strong></p>
</li>
<li><p><strong>缓存</strong>：说白了，就是让数据尽早进入缓存，离程序近一点，不要大量频繁的访问DB。</p>
<p><strong>降级</strong>：如果不是核心链路，那么就把这个服务降级掉。打个比喻，现在的APP都讲究千人千面，拿到数据后，做个性化排序展示，如果在大流量下，这个排序就可以降级掉！</p>
<p><strong>限流</strong>：大家都知道，北京地铁早高峰，地铁站都会做一件事情，就是限流了！想法很直接，就是想在一定时间内把请求限制在一定范围内，保证系统不被冲垮，同时尽可能提升系统的吞吐量。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo搭建个人博客</title>
    <url>/article/4b8dd3b5.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;搭建个人博客是一直想要做的事情，刚好在B站上面看到了相关视频，趁此机会好好搭建自己的博客，同时记录一下自己的学习经历。</p>
<span id="more"></span>

<h1 id="博客框架选择"><a href="#博客框架选择" class="headerlink" title="博客框架选择"></a>博客框架选择</h1><p>&emsp;&emsp;该博客采用的是静态博客的搭建方式，区别于动态博客，静态博客没有后台管理，管理起来相对没有那么方便。好处是搭建方便，上手快，一两天就可以搭建完成。本篇文章主要介绍如何在<strong>Windows系统</strong>下搭建。</p>
<p>&emsp;&emsp;网上有许多博客搭建框架，我这个博客采用的是<a href="https://hexo.io/zh-cn/">hexo</a>框架，使用人数多，各种主题，网上的教程也比较丰富，出现问题网上解决方法多。其他博客有框架：<strong>Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll</strong>。</p>
<h1 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h1><ul>
<li><p>安装<a href="http://git-scm.com/">Git</a></p>
<ul>
<li>安装成功，鼠标右键可以看到相关git bash</li>
</ul>
</li>
<li><p>需要一个<a href="https://github.com/">GitHub</a>账号或者gitee</p>
<ul>
<li>将本机的git与github绑定</li>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/103391101">https://zhuanlan.zhihu.com/p/103391101</a></li>
</ul>
</li>
<li><p>安装<a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p>
<ul>
<li><p>hexo基于node.js</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">Hexo 版本</th>
<th align="left">最低兼容 Node.js 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5.0+</td>
<td align="left">10.13.0</td>
</tr>
<tr>
<td align="left">4.1 - 4.2</td>
<td align="left">8.10</td>
</tr>
<tr>
<td align="left">4.0</td>
<td align="left">8.6</td>
</tr>
<tr>
<td align="left">3.3 - 3.9</td>
<td align="left">6.9</td>
</tr>
<tr>
<td align="left">3.2 - 3.3</td>
<td align="left">0.12</td>
</tr>
<tr>
<td align="left">3.0 - 3.1</td>
<td align="left">0.10 or iojs</td>
</tr>
<tr>
<td align="left">0.0.1 - 2.8</td>
<td align="left">0.10</td>
</tr>
</tbody></table>
</li>
<li><p>windows用户使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</li>
<li><p>安装完成之后，win+r，输入命令查看安装版本，判断是否安装成功</p>
<p><img src="/article/4b8dd3b5/image-20210803143849473.png" alt="查看安装版本"></p>
</li>
</ul>
</li>
</ul>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>&emsp;&emsp;在完成了上面的准备工作之后，就可以开始正式安装hexo框架了。下面的命令本人都是在win+R命令行下输入操作的，当然也可以在git bash下完成，看个人习惯即可。</p>
<blockquote>
<p>hexo的安装及后续插件的安装，都是使用npm来进行安装</p>
</blockquote>
<ol>
<li><p>输入安装hexo命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
<li><p>初始化hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">注：&lt;folder&gt;表示你将要新建的博客在本地的文件夹位置，比如 D:\Blog</span><br><span class="line">   该文件夹必须为空</span><br></pre></td></tr></table></figure></li>
<li><p>安装完之后，文件夹一般有以下目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  #配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source  #资源目录，你的博客就在这里，还有一些图片也可能会放在这里</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes  #主题目录，里面放你需要的主题，可以根据自己需要更换</span><br></pre></td></tr></table></figure></li>
<li><p>查看静态部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">注：输入这两条命令之后，打开浏览器输入localhost:4000即可看到静态部署的页面</span><br></pre></td></tr></table></figure>

<p><img src="https://img2.baidu.com/it/u=3385728479,3659911900&fm=15&fmt=auto&gp=0.jpg" alt="默认主题"></p>
</li>
</ol>
<h1 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h1><ol>
<li><p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br><span class="line"></span><br><span class="line">注：新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</span><br></pre></td></tr></table></figure></li>
<li><p>新建文章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line">注：[layout]具体就是博客需要放在source目录下的哪个文件夹，默认_post</span><br><span class="line">   新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。</span><br><span class="line">   如果标题包含空格的话，请使用引号括起来。</span><br></pre></td></tr></table></figure></li>
<li><p>新建页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br><span class="line"></span><br><span class="line">注： 不指定--path,Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。</span><br><span class="line">	除了--path，还有下面的可选参数（新建文章也适用）</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>, <code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
</li>
<li><p>网站部署</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>, <code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>, <code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>, <code>--concurrency</code></td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
<tr>
<td align="left"><code>-g</code>,<code>--generate</code></td>
<td align="left">生成静态文件</td>
</tr>
</tbody></table>
<blockquote>
<p>一般修改完网站的配置等信息之后，<strong>使用<code>hexo g</code>和<code>hexo d</code>即可更新网站</strong>。不行的话，最前面<strong>再加上<code>hexo cl</code></strong></p>
</blockquote>
</li>
<li><p>静态部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line"></span><br><span class="line">注： 启动本地服务器，访问网址为： http://localhost:4000/</span><br><span class="line">	简写为`hexo s`</span><br><span class="line">	一般可以在线看修改的效果，不用重新启动，样式变化也会随之变化</span><br></pre></td></tr></table></figure></li>
<li><p>清除缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">注： 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">	当发现重新部署无效时，可以使用该命令。</span><br></pre></td></tr></table></figure></li>
<li><p>其他命令</p>
<blockquote>
<p>命令在<a href="https://hexo.io/zh-cn/docs/commands">官方文档</a>都有详细介绍，本文暂将用到的列出如上。</p>
<p>一般命令都可以缩写前面一两个字母即可，比如<code>hexo cl</code>清除缓存。</p>
</blockquote>
</li>
</ol>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><blockquote>
<p>Hexo提供了许多可供选择的主题，可在<a href="https://hexo.io/themes/">官方文档</a>选择自己喜欢的主题样式。</p>
</blockquote>
<p>下面介绍更换主题的步骤（以<a href="https://github.com/theme-next/hexo-theme-next">next主题</a>为例）：</p>
<ol>
<li><p>选择自己喜欢的主题之后，将其GitHub仓库clone到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">注： 如果clone过慢可以尝试直接下载到本地，然后解压到themes目录下面，并将文件夹改名为主题名</span><br></pre></td></tr></table></figure></li>
<li><p>修改博客目录下的配置文件</p>
<p>直接查找<code>themes</code>，把默认的主题替换成你主题的名字</p>
</li>
<li><p>重新部署网站</p>
</li>
</ol>
<h1 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h1><p>&emsp;&emsp;在完成上面的步骤之后，你的博客还是只能在自己电脑上通过<code>http://localhost:4000/</code>访问。想分享给别人看就需要通过部署域名来实现，或者也可以通过GitHub（gitee)来实现。这里介绍怎么部署到GitHub上面。</p>
<ol>
<li><p>首先，你需要新建一个仓库</p>
<p><img src="/article/4b8dd3b5/image-20210803155904543.png" alt="新建仓库"></p>
<p>仓库名你自己的GitHub名字.github.io即可，比如我的仓库名<code>a-cipher.github.io</code></p>
<p>仓库地址就是你这个仓库的网址，比如我的<code>https://github.com/a-cipher/a-cipher.github.io.git</code></p>
</li>
<li><p>修改配置文件</p>
<p>划到最下面，或者直接搜索<code>repository</code>,在后面加上你的仓库地址即可</p>
<p><img src="/article/4b8dd3b5/image-20210803160502744.png" alt="修改配置文件"></p>
</li>
<li><p>安装git部署插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后三部曲，重新部署。输入 <a href="https://fengye97.github.io/">https://xxx.github.io</a> 就可以打开你的网页了：</p>
</li>
</ol>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><blockquote>
<p>整个博客的搭建花了一两天的时间，记录自己遇到的问题</p>
</blockquote>
<ul>
<li><p>一般在更换主题之后，都要进行自定义的配置修改，基本修改都在_config.yml里面进行修改。</p>
<p>注意区分：博客目录下面有一个_config.yml，你的主题下面还有一个 _config.yml。</p>
</li>
<li><p>配置文件都是yml文件，需要按照yaml语法来进行编写。比如：<code>theme: next</code>，冒号后面有一个空格，给一个变量赋多个值的写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span> [<span class="string">标签1</span>,<span class="string">标签2</span>,<span class="string">标签3</span>]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">标签2</span></span><br></pre></td></tr></table></figure>

<p>如果命令行报错指向你具体的哪一行，很可能就是语法错误。</p>
</li>
<li><p>部署的时候如果报错有<code>connection</code> <code>ssl</code>这种字眼，大多情况可能是网络连接有错误，可以考虑用<code>tizhi</code></p>
</li>
<li><p>由于hexo博客的编写采用的是markdown语法，编写博客可以考虑使用markdown编辑器来辅助编写，比如Typora。</p>
<p>提供一种输入<code>hexo n</code>就自动打开本地编辑器的办法：</p>
<p>在博客目录下面新建一个scripts目录，里面加上一个js文件，文件名自取，内容如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).exec;</span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">&#x27;start  &quot;D:\Program Files\Typora\Typora.exe&quot; &#x27;</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>markdown语法实现缩进<code>&amp;emsp;&amp;emsp;</code></p>
</li>
<li><p>在搭建博客如果出现问题，大不了把文件全删了重头再来，多试几次就好了。</p>
</li>
<li><p>无论是博客的搭建还是修改主题的样式，官方文档都是好帮手，如果还是解决不了百度即可。</p>
</li>
<li><p>next主题更新之后，原来的custom.styl已经取消，样式修改可以在source目录新建一个<code>Blog\source\_data\styles.styl</code></p>
<p>注意需要将主题配置文件中对应地方取消注释</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li>
<li><p>博客中图片的访问方式</p>
<ol>
<li><p>网络图片直接复制插入即可。</p>
</li>
<li><p>本地图片默认访问规则</p>
<p>图片统一将它们放在博客目录下 <code>source/images</code> 文件夹中。然后通过 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>
<p>也可通过<code>&lt;img src=&quot;/images/image.jpg&quot;&gt;</code>访问，这种可以改变样式。</p>
</li>
<li><p>本地图片，相对路径</p>
<ol>
<li><p>开启站点配置文件 </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 在配置文件加上以下，可以用&#123;% asset_img %&#125;方式</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>md文件创建时会自动创建同名文件夹，把图片放在该目录下面</p>
</li>
<li><p>访问的时候<code>![图片标题](图片名.jpg)</code></p>
<p>或者使用<code>&#123;% asset_img 图片名.png 宽 高 标题 %&#125;</code>，宽高标题可以不写</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>······</p>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></p>
<p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/article/f7ede91d.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;复习Java基础，记录一下一些重要的知识点。</p>
<span id="more"></span>

<p>&emsp;&emsp;主要内容来自Github上的<a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a>，仅作个人学习。</p>
<h2 id="概念常识"><a href="#概念常识" class="headerlink" title="概念常识"></a>概念常识</h2><ol>
<li><p>什么是JVM?</p>
<p>JVM是Java Virtual Machine（Java虚拟机），是运行Java字节码的虚拟机。针对不同系统有不同实现，目的是使用相同的字节码，给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
</li>
<li><p>什么是字节码？</p>
<p>JVM可以理解的代码叫字节码（.class文件），它不面向任何特定的处理器，只面向虚拟机。</p>
</li>
<li><p><strong>Java 程序从源代码到运行一般有哪些步骤？</strong></p>
<p><img src="/article/f7ede91d/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="运行过程"></p>
</li>
<li><p>JDK 和 JRE的概念？</p>
<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
</li>
<li><p>为什么说Java“编译与解释并存”？</p>
<p>编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>
</li>
</ol>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>字符型常量和字符串常量的区别？</p>
<ul>
<li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li>
<li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ul>
</li>
<li><p>标识符和关键字的区别？</p>
<p>简单来说，标识符就相当于名字。关键字就是具有特殊含义的标识符，已经有了特定的含义，只能用于特定的地方。</p>
</li>
<li><p>类和对象之间的关系？</p>
<p>对象是类实例化出来的,对象中含有类的属性,类是对象的抽象。用static修饰的方法是静态的方法或称为共享方法，一般用类名直接调用。</p>
</li>
<li><p>什么是泛型？</p>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说<strong>类型擦除</strong> 。</p>
</li>
<li><p>泛型的使用方式？</p>
<ul>
<li>泛型类，</li>
<li>泛型接口</li>
<li>泛型方法</li>
</ul>
</li>
<li><p>常用的通配符？</p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个 java 类型</li>
<li>K V (key value) 分别代表 java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
</li>
<li><p>==和 equals 的区别</p>
<ul>
<li><p>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p>
</li>
<li><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</li>
<li><p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
</li>
<li><p>一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</p>
</li>
<li><p>```java<br>public class test1 {</p>
<pre><code>public static void main(String[] args) &#123;
    String a = new String(&quot;ab&quot;); // a 为一个引用
    String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样
    String aa = &quot;ab&quot;; // 放在常量池中
    String bb = &quot;ab&quot;; // 从常量池中查找
    if (aa == bb) // true
        System.out.println(&quot;aa==bb&quot;);
    if (a == b) // false，非同一对象
        System.out.println(&quot;a==b&quot;);
    if (a.equals(b)) // true
        System.out.println(&quot;aEQb&quot;);
    if (42 == 42.0) &#123; // true
        System.out.println(&quot;true&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。</span><br><span class="line"></span><br><span class="line">   - 当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。</span><br><span class="line"></span><br><span class="line">   - **敲重点：==比较的是基本数据类型的值，引用类型对象的内存地址；equals比较的是对象是否相等，当调用的equals是被重写的时候，比较的是对象里面的值。**</span><br><span class="line"></span><br><span class="line">8. 什么是hashCode()?</span><br><span class="line"></span><br><span class="line">   `hashCode()` 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</span><br><span class="line"></span><br><span class="line">9. 为什么重写 equals 时必须重写 hashCode 方法？？</span><br><span class="line"></span><br><span class="line">   如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**</span><br><span class="line"></span><br><span class="line">10. 相同hashCode值，他们不一定相等？</span><br><span class="line"></span><br><span class="line">    因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是**不同的对象得到相同的 `hashCode`**）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 基本数据类型</span><br><span class="line"></span><br><span class="line">1. Java中8种基本数据类型有哪些？</span><br><span class="line"></span><br><span class="line">   | 基本类型  | 位数 | 字节 | 默认值  |</span><br><span class="line">   | --------- | ---- | ---- | ------- |</span><br><span class="line">   | `int`     | 32   | 4    | 0       |</span><br><span class="line">   | `short`   | 16   | 2    | 0       |</span><br><span class="line">   | `long`    | 64   | 8    | 0L      |</span><br><span class="line">   | `byte`    | 8    | 1    | 0       |</span><br><span class="line">   | `char`    | 16   | 2    | &#x27;u0000&#x27; |</span><br><span class="line">   | `float`   | 32   | 4    | 0f      |</span><br><span class="line">   | `double`  | 64   | 8    | 0d      |</span><br><span class="line">   | `boolean` | 1    |      | false   |</span><br><span class="line"></span><br><span class="line">   - Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。</span><br><span class="line"></span><br><span class="line">   - `char a = &#x27;h&#x27;`char :单引号，`String a = &quot;hello&quot;` :双引号。</span><br><span class="line"></span><br><span class="line">   - 这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。</span><br><span class="line"></span><br><span class="line">   - 包装类型不赋值就是 `Null` ，而基本类型有默认值且不是 `Null`。</span><br><span class="line"></span><br><span class="line">2. 什么是自动装箱和拆箱？</span><br><span class="line"></span><br><span class="line">   - **装箱**：将基本类型用它们对应的引用类型包装起来；</span><br><span class="line"></span><br><span class="line">   - **拆箱**：将包装类型转换为基本数据类型；</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     Integer i = 10;  //装箱</span><br><span class="line">     int n = i;   //拆箱</span><br><span class="line">     </span><br><span class="line">     //Integer i = 10 等价于 Integer i = Integer.valueOf(10)</span><br><span class="line">     //int n = i 等价于 int n = i.intValue();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>8 种基本类型的包装类和常量池?</p>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code></p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
</li>
<li><p><strong>整型包装类对象之间值的比较</strong>?</p>
<p><img src="https://img-blog.csdnimg.cn/20210422164544846.png" alt="img"></p>
</li>
<li><p>什么是引用数据类型？有哪些？</p>
<p>引用类型在堆里，基本类型在栈里。栈空间小且连续，往往会被放在缓存。引用类型cache miss率高且要多一次解引用。对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高</p>
<p>引用数据类型主要包括：类，接口，数组</p>
</li>
</ol>
<h2 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h2><ol>
<li><p>final</p>
<p><strong>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p>
<ol>
<li><strong>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</strong></li>
<li><strong>final 修饰的方法不能被重写；</strong></li>
<li><strong>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></li>
</ol>
</li>
<li><p>static</p>
<ol>
<li><strong>修饰成员变量和成员方法</strong>：被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过<strong>类名调用</strong>。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</li>
<li>静态代码块</li>
<li>修饰类(只能修饰内部类)</li>
<li>静态导包(用来导入类中的静态资源，1.5 之后的新特性)</li>
</ol>
</li>
<li><p>this</p>
<p>this 关键字用于引用类的当前实例</p>
</li>
<li><p>super</p>
<p>super 关键字用于从子类访问父类的变量和方法</p>
</li>
<li><p>this和super使用注意？</p>
<ul>
<li>在构造器中使用 <code>super()</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li>
<li>this、super 不能用在 static 方法中。 <strong>this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong></li>
</ul>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li><p>在一个静态方法内调用一个非静态成员为什么是非法的?</p>
<p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
<li><p>静态方法与实例化方法的区别？</p>
<ul>
<li>调用方式不同<ul>
<li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</li>
</ul>
</li>
<li><strong>访问类成员是否存在限制</strong><ul>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java中为什么只有值传递？</p>
<p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容</strong>。</p>
</li>
<li><p>方法参数的使用情况？</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
</li>
<li><p>重载和重写的区别？</p>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
</li>
<li><p>深拷贝 vs 浅拷贝</p>
<ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol>
<li><p>面向对象和面向过程的区别？</p>
<ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
</li>
<li><p>成员变量与局部变量的区别有哪些？</p>
<ol>
<li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
</li>
<li><p>对象实体与对象引用的区别？</p>
<p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
</li>
<li><p>对象相等和指向他们的引向相等有何不同？</p>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
</li>
<li><p>构造方法是否可以被重写？</p>
<p>构造方法不可以被重写，但是可以重载。</p>
</li>
<li><p>面向对象的三大特征？</p>
<ul>
<li>封装 ：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li>
<li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。<ul>
<li><strong>关于继承如下 3 点请记住：</strong><ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
</li>
</ul>
</li>
<li>多态：对于一个方法，我们有不同的操作方式。<ul>
<li><strong>多态的特点:</strong><ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>String StringBuffer 和 StringBuilder 的区别是什么?</p>
<ol>
<li>可变性方面<ul>
<li>string由final修饰，不可变</li>
<li>StringBuilder 和 StringBuffer 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</li>
</ul>
</li>
<li>线程安全方面<ul>
<li>string 中的对象是不可变的，也就可以理解为常量，线程安全。</li>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li>
<li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
</li>
<li>性能<ul>
<li>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
</ul>
</li>
<li>使用总结<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol>
<li><p>什么是反射？</p>
<p>Java 反射，就是在运行状态中。</p>
<ul>
<li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li>
<li>获取任意对象的属性，并且能改变对象的属性</li>
<li>调用任意对象的方法</li>
<li>判断任意一个对象所属的类</li>
<li>实例化任意一个类的对象</li>
</ul>
</li>
<li><p>反射机制的优缺点？</p>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>
</ul>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li><p>异常层次结构图？</p>
<p><img src="/article/f7ede91d/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Java异常类层次结构图"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
</li>
<li><p>受检查异常和不受检查异常？</p>
<p><img src="/article/f7ede91d/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png" alt="Java异常类层次结构图2"></p>
<ul>
<li>不受检查异常主要是<code>RuntimeException</code>及其子类；Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li>
<li>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。</li>
</ul>
</li>
<li><p>Throwable 类常用方法?</p>
<ul>
<li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
</li>
<li><p>try-catch-finally?</p>
<ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。<ul>
<li><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong><ol>
<li>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>try-with-resourse(java7新增)?</p>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
</li>
</ol>
<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><ol>
<li><p>什么是序列化？什么是反序列化？</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li>
<li>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></li>
</ul>
</li>
<li><p>有些字段不想进行序列化，怎么解决？</p>
<p>使用 <code>transient</code> 关键字修饰。<code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
</li>
<li><p>Java中键盘输入的方式？</p>
<p>方法 1：通过 <code>Scanner</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 <code>BufferedReader</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure></li>
<li><p>IO流的种类？</p>
<p><img src="/article/f7ede91d/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p>
</li>
<li><p>字节流和字符流？</p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
</li>
</ol>
<h2 id="疑难点"><a href="#疑难点" class="headerlink" title="疑难点"></a>疑难点</h2><ol>
<li><p>equals的使用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;SnailClimb&quot;</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="comment">//1.&quot;SnailClimb&quot;.equals(str);// false</span></span><br><span class="line"><span class="comment">//2.Objects.equals(null,&quot;SnailClimb&quot;);// false</span></span><br></pre></td></tr></table></figure></li>
<li><p>BigDecimsl的作用？</p>
<p><strong>来定义浮点数的值，再进行浮点数的运算操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); </span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure></li>
<li><p>BigDecimal 的使用注意事项</p>
<p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p>
<p><img src="/article/f7ede91d/BigDecimal.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p>
</li>
<li><p>基本数据类型与包装数据类型的使用标准？</p>
<p>Reference:《阿里巴巴Java开发手册》</p>
<ul>
<li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li>
<li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。 （rpc 远程过程调用）</li>
<li>【推荐】所有的局部变量使用基本数据类型。</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识总结</title>
    <url>/article/df19d329.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;MySQL是常用的关系型数据库，MySQL作为企业中常用的数据库之一，了解MySQL并熟练掌握MySQL的使用是十分重要。现将MySQL知识总结记录下来，方便个人学习查阅。主要知识来源GitHub开源项目<a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a>。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>什么是数据库,数据库管理系统,数据库系统,数据库管理员?</p>
<ul>
<li><strong>数据库</strong> :数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>
<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用语用于建立、使用和维护数据库。</li>
<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>
<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator,简称 DBA)负责全面管理和控制数据库系统。</li>
</ul>
</li>
<li><p>什么是关系型数据库？</p>
<p>建立在关系模型基础上的数据库。关系模型表明了数据库所存数据之间的联系（一对一，一对多，多对多）。</p>
<p>大部分关系型数据库使用SQL来操作数据库中的数据。常见关系型数据库MySQL（3306），Oracle，SQL server等。</p>
</li>
</ol>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ol>
<li><p>查看MySQL存储引擎命令？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<p>默认InnoDB，属于事务性引擎，支持事务</p>
</li>
<li><p>MyISAM 和 InnoDB 的区别？</p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>🌈 拓展一下：</p>
<p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p>🌈 拓展一下：</p>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p>
<p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p>
</li>
<li><p>MyISAM 和 InnoDB 的选择问题？</p>
<p>大多情况选择InnoDB，MyISAM不支持事务，崩溃恢复！</p>
</li>
</ol>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><ol>
<li><p>什么是锁机制？</p>
<p>锁是计算机协调多个进程或线程并发访问某一资源的一种机制。</p>
<p>从性能上来分，锁分为乐观锁和悲观锁。</p>
<p>从数据库操作的类型分，锁分读锁和写锁（都是悲观锁）。</p>
<p>从操作数据库的粒度来说，分表锁和行锁</p>
</li>
<li><p>悲观锁？</p>
<p>当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>
<p>悲观锁的实现：</p>
<ol>
<li>传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</li>
<li>Java 里面的同步 synchronized关键字的实现。</li>
</ol>
</li>
<li><p>乐观锁？</p>
<p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。</p>
<p>乐观锁的实现：</p>
<ol>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li>
<li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功</li>
</ol>
</li>
<li><p>读锁和写锁？</p>
<p>读锁（共享锁，S锁 Shared）：针对同一份数据，多个读操作可以同时进行并且不会相互影响</p>
<p>写锁（排它锁，X锁 eXclusive）：在当前写操作完成前，会阻断其他一切的锁</p>
</li>
<li><p><strong>表级锁和行级锁对比？</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
<li>考虑上述特点，表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的web应用；而行级锁适用于高并发环境下，对事务完整性要求较高的系统，如在线事务处理系统。</li>
</ul>
</li>
<li><p>InnoDB 存储引擎锁的机制有哪些？</p>
<ul>
<li>Record lock：记录锁，单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li>
</ul>
</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ol>
<li><p>什么是事务？</p>
<p>逻辑上的一组操作，要不都执行，要不都不执行。</p>
</li>
<li><p>事务的四大特性ACID（关系型数据库事务都有这个特点）？</p>
<ul>
<li><strong>原子性</strong> Atomicity 事务是最小的执行单位，不能再分割。要不都执行，要不都不执行</li>
<li><strong>一致性</strong> Consistency 执行事务前后，数据需要保持一致</li>
<li><strong>隔离性</strong> Isolation 并发访问时，一个用户事务不能被其他事务所干扰</li>
<li><strong>持久性</strong> Durability 事务提交之后，对数据库中的改变是持久的</li>
</ul>
</li>
<li><p>常见的并发异常？</p>
<ul>
<li>脏读：一个事务读到了另外一个事务修改了但是没有提交的数据</li>
<li>不可重复读：一个事务读多次同一数据，中途该数据被另外一个事务读取并修改，导致两次读到的数据不一致</li>
<li>幻读：一个事务读多次同一数据，中途该数据被另外一个并发事务插入或者删除，导致随后读取的数据发生变化，像幻觉一样</li>
<li>丢失修改：两个事务先后访问并修改数据，导致第一个修改的数据丢失</li>
</ul>
</li>
<li><p>事务隔离级别？</p>
<ul>
<li><p>READ-UNCOMMITTED 读取未提交</p>
</li>
<li><p>READ-COMMITTED 读取已提交，可避免脏读</p>
</li>
<li><p>REPEATABLE-READ 可重复读，多次读取数据一致，可避免脏读和不可重复读</p>
</li>
<li><p>SERIALIZABLE 可串行化，所有事务依次执行，可防止脏读，不可重复读，幻读</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>MySQL默认隔离级别？</p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
</li>
</ol>
<h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><ol>
<li><p>什么是mvvc?</p>
<p>英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。某种程度上就是乐观锁的一种实现方式。在Java编程中，如果把乐观锁看成一个接口，MVCC便是这个接口的一个实现类而已。</p>
</li>
<li><p>MVVC机制的实现？</p>
<p>MVCC机制的实现是通过read-view机制与undo日志版本链对比，来使得不同的事务会根据数据版本链进行比对来读取同一条数据在版本链上的不同版本数据，进行数据的隔离。下面通过一张图来详细描述MVCC的实现机制。</p>
<p>首先我们介绍一下日志版本链，日志版本链是指一行数据被多个事务依次修改后，每次事务修改完，mysql都会保留修改前的数据的undo回滚日志，同时使用了两个隐藏字段trx_id(事务号)和roll_pointer(回滚指针)把这些回滚日志串联起来形成一个版本链。具体的如图所示：</p>
<p>图中每一行代表一个回滚日志，每个日志末尾都有一个roll_pointer指向上一条日志。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/paRXy9ic0MZNpBBEyR8WP6eaD1EGWUbMia2uEdpkQL0ZhLgBCf955qN3LGMAwkO2dZwu56NZpAMBQNSD0T9Hzn7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当事务开启时，执行任何查询sql都会生成当前事务的一致性视图read-view，生成的视图在事务结束之前都不会变化，这个视图由查询时所有未提交事务id数组和已创建的最大事务id组成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/paRXy9ic0MZNpBBEyR8WP6eaD1EGWUbMia3xbmAo1Cf9ZHB2Hh4HlB0LmibyTR9ufMKjmFgYZ1fK6POMrh3ibYIofA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在我们当前的日志版本链内，查询了一条数据，创建了一个对应的read-view，那么它应该是这样，[80,81,82],202 ,数组内最小的id为min_id,最大的事务id(max_id)是202。</p>
<p>具体的版本链比对规则：</p>
<ol>
<li><p>如果trx_id&lt;min_id , 表示这个版本是已提交的事务产生的，可见</p>
</li>
<li><p>如果trx_id &gt;max_id，表示是由生成read-view之后的事务版本生成的，不可见</p>
</li>
<li><p>如果trx_id落在min_id和max_id之间，分为两种情况：</p>
</li>
<li><ol>
<li>如果trx_id在read-view的数组内，不可见</li>
<li>如果trx_id不在read-view的数组内，可见</li>
</ol>
</li>
</ol>
<p>PS：事务的trx_id生成规则是依次递增的，所以后面生成的trx_id一定比前面的大。事务的真正启动，是在执行第一个修改操作数据库的语句开始的，查询语句不生成事务id。</p>
<p>最后，再提供一张图方便大家理解：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/paRXy9ic0MZNpBBEyR8WP6eaD1EGWUbMiaoVRK5ibI0AYIktrbibKicWcUZibsNllxkW0NantMiaiaOGgb9R3WRFUPPkNQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol>
<li><p>什么是索引，有什么用？</p>
<p>索引是一种快速查询和检索数据的数据结构，作用相当于目录的作用。常见的索引有：B树，B+树和 Hash。</p>
</li>
<li><p>索引的优缺点？</p>
<ul>
<li>优点：加快数据检索速度，创建唯一性索引，可以保证每一行数据的唯一性</li>
<li>缺点：创建维护索引需要时间，同时占用一定空间。</li>
</ul>
</li>
<li><p>Hash?</p>
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p>
</li>
<li><p>MySQL中不使用Hash作为索引数据结构的原因？</p>
<p><strong>1.Hash 冲突问题</strong> ：多个不同的 key 最后得到的 index 相同。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
</li>
<li><p>B 树&amp; B+树 ？</p>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li><p>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p>
</li>
<li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
<p><img src="https://img-blog.csdnimg.cn/20210420165409106.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>索引类型？</p>
<ul>
<li>主键索引 数据表的主键列使用的就是主键索引。</li>
<li>二级索引（辅助索引） <strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></li>
</ul>
</li>
<li><p>聚集索引？</p>
<p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>优点：查询速度快，整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p>缺点：依赖有序的数据，更新代价大。</p>
</li>
<li><p>非聚集索引？</p>
<p><strong>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</strong></p>
<p>优点：<br>更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p>缺点：<br>跟聚集索引一样，非聚集索引也依赖于有序的数据<br>可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p>
</li>
<li><p>创建索引的注意事项？</p>
<p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
</li>
</ol>
<h2 id="语句执行流程"><a href="#语句执行流程" class="headerlink" title="语句执行流程"></a>语句执行流程</h2><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎<ul>
<li>先判断你有没有权限</li>
<li>查询缓存中是否有数据（MySQL 8.0 之后移除）</li>
<li>分析查询语句，词条分析（提取其中关键字）+ 语法分析（判断是否符合语法）</li>
<li>优化器确定执行的方案，据自己的优化算法进行选择执行效率最好的一个方案（不一定最好）</li>
<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>
</ul>
</li>
<li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)<ul>
<li>update tb_student A set A.age=’19’ where A.name=’ 张三 ‘;</li>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
</li>
</ul>
<h2 id="存储时间"><a href="#存储时间" class="headerlink" title="存储时间"></a>存储时间</h2><ol>
<li><p>MySQL中使用什么存储时间好？</p>
<p>切记不要用字符串存储时间，占用空间大，日期效率低</p>
<p>每种方式都有各自的优势，根据实际场景才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>
</li>
</ol>
<p><img src="/article/df19d329/%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.jpg" alt="常用日期存储方式"></p>
<h2 id="易混点"><a href="#易混点" class="headerlink" title="易混点"></a>易混点</h2><ol>
<li>drop , truncate , delete 之间的区别？<ul>
<li>drop(丢弃数据): <code>drop table 表名</code> ，删表</li>
<li>truncate (清空数据) : <code>truncate table 表名</code> ，清空表的数据</li>
<li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除具体的某一行数据</li>
<li>drop和truncate属于DDL语言，数据定义语言，delete属于DML语言，数据操作语言</li>
</ul>
</li>
<li>……</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>本文主要知识来源于网络，仅作为个人学习使用</strong></p>
<p>参考来源：</p>
<p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<p><a href="https://www.jianshu.com/p/d2ac26ca6525">https://www.jianshu.com/p/d2ac26ca6525</a></p>
<p><a href="https://mp.weixin.qq.com/s/7KblQbpWXTW3I9MHWRvnkg">https://mp.weixin.qq.com/s/7KblQbpWXTW3I9MHWRvnkg</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之线性结构</title>
    <url>/article/37b7424c.html</url>
    <content><![CDATA[<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol>
<li><p>什么是线性表？</p>
<p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p>
<span id="more"></span>

<p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。</p>
<p><strong>数组、链表、栈、队列是四种最常见的线性表.</strong></p>
</li>
<li><p>数组介绍？</p>
<p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p>
<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p>
</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li><p>什么是链表？</p>
<p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>
</li>
<li><p>链表的优缺点？</p>
<ul>
<li>优点：<ul>
<li>增删数据方便</li>
<li>支持天然扩容</li>
</ul>
</li>
<li>缺点<ul>
<li>查找数据不方便</li>
<li>不支持随机访问</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表？</p>
<p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>
<p><img src="/article/37b7424c/%E5%8D%95%E9%93%BE%E8%A1%A82.png" alt="单链表"></p>
</li>
<li><p>循环链表？</p>
<p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>
<p><img src="/article/37b7424c/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A82.png" alt="循环链表"></p>
</li>
<li><p>双向链表？</p>
<p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><img src="/article/37b7424c/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
</li>
<li><p>双向循环链表？</p>
<p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="/article/37b7424c/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p>
</li>
<li><p>数组 vs 链表</p>
<ul>
<li>数组支持随机访问，而链表不支持。</li>
<li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li>
<li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li>
</ul>
</li>
<li><p>Java中的双向链表（LinkedList）？</p>
<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<p>详细方法参见：<a href="https://www.runoob.com/java/java-linkedlist.html">https://www.runoob.com/java/java-linkedlist.html</a></p>
</li>
</ol>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol>
<li><p>栈简介</p>
<p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p>
<p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设堆栈中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//最坏情况</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//顶端插入和删除元素Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><img src="/article/37b7424c/%E6%A0%88.png" alt="栈"></p>
</li>
<li><p>Java中栈的基本方法？</p>
<p>栈<code>Stack</code>的实现在java.util这个下面，继承于vector</p>
<p>主要方法：</p>
<ul>
<li>push 入栈</li>
<li>pop 返回栈顶元素并出栈</li>
<li>peek 返回栈顶元素不出栈</li>
<li>isEmpty() 栈是否为空</li>
<li>size() 栈的大小（继承自vector）</li>
<li>search() 从对象所在的栈顶部开始的基于1的位置; 返回值-1表示对象不在栈上</li>
</ul>
</li>
<li><p>栈的实现</p>
<p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p>
<p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p>
<blockquote>
<p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] storage;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;<span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//栈中元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GROW_FACTOR = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带初始容量的构造方法。默认容量为8</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带初始容量的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Capacity too small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.capacity = initialCapacity;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> <span class="keyword">int</span>[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            ensureCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        storage[count++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = capacity * GROW_FACTOR;</span><br><span class="line">        storage = Arrays.copyOf(storage, newCapacity);</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素并出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> storage[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素不出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage[count-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyStack myStack = <span class="keyword">new</span> MyStack(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.push(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">4</span>);</span><br><span class="line">myStack.push(<span class="number">5</span>);</span><br><span class="line">myStack.push(<span class="number">6</span>);</span><br><span class="line">myStack.push(<span class="number">7</span>);</span><br><span class="line">myStack.push(<span class="number">8</span>);</span><br><span class="line">System.out.println(myStack.peek());<span class="comment">//8</span></span><br><span class="line">System.out.println(myStack.size());<span class="comment">//8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    System.out.println(myStack.pop());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(myStack.isEmpty());<span class="comment">//true</span></span><br><span class="line">myStack.pop();<span class="comment">//报错：java.lang.IllegalArgumentException: Stack is empty.</span></span><br></pre></td></tr></table></figure></li>
<li><p>栈的应用场景？</p>
<ol>
<li><p>实现浏览器的回退，前进功能</p>
<p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p>
<p><img src="/article/37b7424c/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%80%92%E9%80%80%E5%92%8C%E5%89%8D%E8%BF%9B.png" alt="栈实现浏览器倒退和前进"></p>
</li>
<li><p>检查符号是否成对出现</p>
<blockquote>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断该字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]” 、”([)]” 则不是。</p>
</blockquote>
<p>这个问题实际是 Leetcode 的一道题目（20题），我们可以利用栈 <code>Stack</code> 来解决这个问题。</p>
<ol>
<li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li>
<li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 括号之间的对应规则</span></span><br><span class="line">    HashMap&lt;Character, Character&gt; mappings = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    mappings.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappings.containsKey(chars[i])) &#123;</span><br><span class="line">            <span class="keyword">char</span> topElement = stack.empty() ? <span class="string">&#x27;#&#x27;</span> : stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (topElement != mappings.get(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>反转字符串</p>
<p>将字符串中的每个字符先入栈再出栈就可以了。</p>
</li>
<li><p>维护函数调用</p>
<p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p>
</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol>
<li><p>队列简介</p>
<p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p>
<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设队列中有n个元素。</span><br><span class="line">访问：O（n）<span class="comment">//最坏情况</span></span><br><span class="line">插入删除：O（<span class="number">1</span>）<span class="comment">//后端插入前端删除元素Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p><img src="/article/37b7424c/%E9%98%9F%E5%88%97.png" alt="队列"></p>
</li>
<li><p>队列分类</p>
<p>主要分为单队列，循环队列</p>
<ol>
<li><p>单队列</p>
<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p>
<p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p>
<p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（<strong>越界</strong>）。</p>
<blockquote>
<p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front 指针指向对头元素</strong>，<strong>rear 指针指向队列最后一个元素的下一个位置</strong>，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p>
</blockquote>
<p><img src="/article/37b7424c/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E5%81%87%E6%BA%A2%E5%87%BA1.png" alt="顺序队列假溢出"></p>
</li>
<li><p>循环队列</p>
<p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>
<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>
<p><img src="/article/37b7424c/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="循环队列"></p>
<p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p>
<ol>
<li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li>
<li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li>
</ol>
<p><img src="/article/37b7424c/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-%E5%A0%86%E6%BB%A1.png" alt="循环队列-队满"></p>
</li>
</ol>
</li>
<li><p>应用场景？</p>
<p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>
<ul>
<li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li>
<li><strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li>
<li>Linux 内核进程队列（按优先级排队）</li>
<li>现实生活中的派对，播放器上的播放列表;</li>
<li>消息队列</li>
<li>等等……</li>
</ul>
</li>
<li><p>Java中的队列？</p>
<p><code>Queue</code>是队列，只能一头进，另一头出。</p>
<p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code>Deque</code>。</p>
<p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p>
<ul>
<li>既可以添加到队尾，也可以添加到队首；</li>
<li>既可以从队首获取，又可以从队尾获取。</li>
</ul>
<p>我们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Queue</th>
<th align="left">Deque</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加元素到队尾</td>
<td align="left">add(E e) / offer(E e)</td>
<td align="left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td align="left">取队首元素并删除</td>
<td align="left">E remove() / E poll()</td>
<td align="left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td align="left">取队首元素但不删除</td>
<td align="left">E element() / E peek()</td>
<td align="left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td align="left">添加元素到队首</td>
<td align="left">无</td>
<td align="left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td align="left">取队尾元素并删除</td>
<td align="left">无</td>
<td align="left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td align="left">取队尾元素但不删除</td>
<td align="left">无</td>
<td align="left">E getLast() / E peekLast()</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ol>
<li><p>什么是哈希函数？</p>
<p><strong>哈希函数就是根据确定根据这个函数和查找关键字key，可以直接确定查找值所在位置</strong>，而不需要一个个比较。这样就<strong>“预先知道”</strong>key所在的位置，直接找到数据，提升效率。<br>即地址<strong>index=H（key）</strong><br>说白了，hash函数就是根据key计算出应该存储地址的位置，而<strong>哈希表是基于哈希函数建立的一种查找表</strong>（也叫散列表）。</p>
</li>
<li><p>哈希函数的构造方法？</p>
<ul>
<li><p><strong>直接定制法</strong><br>哈希函数为关键字的线性函数如 H（key）=a*key+b<br>这种构造方法比较简便，均匀，但是有很大限制，仅限于地址大小=关键字集合的情况</p>
</li>
<li><p><strong>数字分析法</strong><br>此种方法通常用于数字位数较长的情况，必须数字存在一定规律，其必须知道数字的分布情况，比如上面的例子，我们事先知道这个班级的学生出生在同一年，同一个地区。</p>
</li>
<li><p><strong>平方取中法</strong><br>如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。<br>这种方法适合事先不知道数据并且数据长度较小的情况</p>
</li>
<li><p><strong>折叠法</strong><br>如果数字的位数很多，可以将数字分割为几个部分，取他们的叠加和作为hash地址<br>该方法适用于数字位数较多且事先不知道数据分布的情况</p>
</li>
<li><p><strong>除留余数法</strong>用的较多  </p>
<p>H（key）=key MOD p （p&lt;=m m为表长）<br>很明显，如何选取p是个关键问题。</p>
</li>
<li><p><strong>随机数法</strong> H（key） =Random（key） 取关键字的随机函数值为它的散列地址</p>
</li>
</ul>
</li>
<li><p><strong>hash函数设计的考虑因素</strong></p>
<ol>
<li>计算散列地址所需要的时间（即hash函数本身不要太复杂）</li>
<li>关键字的长度</li>
<li>表长</li>
<li>关键字分布是否均匀，是否有规律可循</li>
<li>设计的hash函数在满足以上条件的情况下尽量减少冲突</li>
</ol>
</li>
<li><p>什么是哈希冲突？</p>
<p>不同的key值产生相同的地址。</p>
</li>
<li><p>哈希冲突的解决？</p>
<ol>
<li>开放定制法</li>
<li>链地址法</li>
<li>公共溢出区法<br>建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。</li>
<li>再散列法<br>准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……<br>重点了解一下<strong>开放定制法</strong>和<strong>链地址法</strong></li>
</ol>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<p><a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p>
<p><a href="https://blog.csdn.net/u011109881/article/details/80379505">https://blog.csdn.net/u011109881/article/details/80379505</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a></p>
<p><a href="https://www.pdai.tech/md/algorithm/alg-basic-tree-search.html">https://www.pdai.tech/md/algorithm/alg-basic-tree-search.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot学习笔记2</title>
    <url>/article/a25851fc.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;之前学的springboot笔记2，放上来方便查看</p>
<span id="more"></span>
<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><h3 id="1-1-properties"><a href="#1-1-properties" class="headerlink" title="1.1 properties"></a>1.1 properties</h3><p>当配置文件中的中文乱码时，可以在setting里面进行修改,IDEA中设置 <code>File Encodings</code></p>
<p>修改之后还是不失效，可以把配置文件删了，再重新创一个</p>
<h3 id="1-2-yaml"><a href="#1-2-yaml" class="headerlink" title="1.2 yaml"></a>1.2 yaml</h3><p>application.yml也可以用来当作配置文件使用</p>
<p><strong>配置文件在同一位置同时具有<code>.properties</code>和<code>.yml</code>格式，<code>.properties</code>则优先。</strong></p>
<p>application.properties和application.yml都会生效</p>
<p>基本语法如下：</p>
<ul>
<li><p>key: value；<strong>kv之间有空格</strong></p>
</li>
<li><p>大小写敏感</p>
</li>
<li><p><strong>使用缩进表示层级关系</strong></p>
</li>
<li><p>缩进不允许使用tab，只允许空格，idea会自动转换</p>
</li>
<li><p>缩进的空格数不重要，只要相同层级的元素左对齐即可</p>
</li>
<li><p>‘#’表示注释</p>
</li>
<li><p>字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义/不转义</p>
<ul>
<li>双引号不会转义</li>
<li>单引号会转义</li>
</ul>
</li>
</ul>
<h3 id="1-3-配置提示"><a href="#1-3-配置提示" class="headerlink" title="1.3 配置提示"></a>1.3 配置提示</h3><p>直接在yaml文件中编写配置，没有提示，可以加入相应的依赖来实现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--打包时忽略自定义类配置提示工具--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-Web开发"><a href="#2-Web开发" class="headerlink" title="2.Web开发"></a>2.Web开发</h2><h3 id="2-1-SpringMvc-自动配置"><a href="#2-1-SpringMvc-自动配置" class="headerlink" title="2.1 SpringMvc 自动配置"></a>2.1 SpringMvc 自动配置</h3><p>详见官网：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications</a></p>
<p>（下面为谷歌翻译原文档）</p>
<p>Spring Boot 为 Spring MVC 提供了自动配置，适用于大多数应用程序。</p>
<p>自动配置在 Spring 的默认值之上添加了以下功能：</p>
<ul>
<li>包括<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>beans。</li>
<li>支持提供静态资源，包括对 WebJars 的支持（<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.static-content">本文档稍后介绍</a>）。</li>
<li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code>beans。</li>
<li>支持<code>HttpMessageConverters</code>（<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.message-converters">在本文档后面介绍</a>）。</li>
<li><code>MessageCodesResolver</code>的自动注册（<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.message-codes">在本文档后面介绍</a>）。</li>
<li>静态<code>index.html</code>支持。</li>
<li><code>ConfigurableWebBindingInitializer</code>bean 的自动使用（<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.binding-initializer">本文档稍后介绍</a>）。</li>
</ul>
<p>如果您想保留那些 Spring Boot MVC 自定义并进行更多<a href="https://docs.spring.io/spring-framework/docs/5.3.8/reference/html/web.html#mvc">MVC 自定义</a>（拦截器、格式化程序、视图控制器和其他功能），您可以添加自己<code>@Configuration</code>的类型类，<code>WebMvcConfigurer</code>但<strong>不添加</strong> <code>@EnableWebMvc</code>.</p>
<p>如果你想提供的定制情况<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或者<code>ExceptionHandlerExceptionResolver</code>，仍然保持弹簧引导MVC自定义，你可以声明类型的bean<code>WebMvcRegistrations</code>，并用它来提供这些组件的定制实例。</p>
<p>如果你想利用Spring MVC中的完全控制，你可以添加自己的<code>@Configuration</code>注解为<code>@EnableWebMvc</code>，或者添加自己的<code>@Configuration</code>-annotated<code>DelegatingWebMvcConfiguration</code>中的Javadoc中所述<code>@EnableWebMvc</code>。</p>
<p>需要SpringMVC的什么功能。编写一个入口给容器中添加一个  WebMvcConfigurer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、WebMvcConfigurer定制化SpringMVC的功能</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 自定义内容协商策略</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> configurer</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//Map&lt;String, MediaType&gt; mediaTypes</span></span><br><span class="line">                Map&lt;String, MediaType&gt; mediaTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;json&quot;</span>,MediaType.APPLICATION_JSON);</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;xml&quot;</span>,MediaType.APPLICATION_XML);</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;gg&quot;</span>,MediaType.parseMediaType(<span class="string">&quot;application/x-guigu&quot;</span>));</span><br><span class="line">                <span class="comment">//指定支持解析哪些参数对应的哪些媒体类型</span></span><br><span class="line">                ParameterContentNegotiationStrategy parameterStrategy = <span class="keyword">new</span> ParameterContentNegotiationStrategy(mediaTypes);</span><br><span class="line"><span class="comment">//                parameterStrategy.setParameterName(&quot;ff&quot;);</span></span><br><span class="line"></span><br><span class="line">                HeaderContentNegotiationStrategy headeStrategy = <span class="keyword">new</span> HeaderContentNegotiationStrategy();</span><br><span class="line"></span><br><span class="line">                configurer.strategies(Arrays.asList(parameterStrategy,headeStrategy));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">                converters.add(<span class="keyword">new</span> GuiguMessageConverter());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">                UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">                <span class="comment">// 不移除；后面的内容。矩阵变量功能就可以生效</span></span><br><span class="line">                urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">                configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-简单功能分析"><a href="#2-2-简单功能分析" class="headerlink" title="2.2 简单功能分析"></a>2.2 简单功能分析</h3><h4 id="1-静态资源的访问"><a href="#1-静态资源的访问" class="headerlink" title="1. 静态资源的访问"></a>1. 静态资源的访问</h4><ul>
<li><p>默认情况下，Spring Boot 可以访问名为<code>/static</code>（或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）下的静态资源</p>
</li>
<li><p>访问路径：localhost:8080/静态资源文件名</p>
</li>
<li><p>原理： 静态映射/**</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#访问路径加resources前缀</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">&quot;/resources/**&quot;</span></span><br><span class="line">  <span class="comment">#默认静态资源文件夹改变</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> [ <span class="string">classpath:/haha/</span> ]</span><br></pre></td></tr></table></figure>

<p>​        注意点：程序重新启动记得在maven生存周期里面，clean</p>
<p>​                <img src="/SpringBoot-2-02.assets/image-20210714124006860.png" alt="image-20210714124006860"></p>
<h4 id="2-Webjars"><a href="#2-Webjars" class="headerlink" title="2. Webjars"></a>2. Webjars</h4><p><a href="https://www.webjars.org/">https://www.webjars.org/</a></p>
<ul>
<li>先导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>原理，访问META-INF/resources下面的路径</p>
<p><img src="/SpringBoot-2-02.assets/image-20210714124849592.png" alt="image-20210714124849592"></p>
</li>
</ul>
<p>访问地址：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js">http://localhost:8080/webjars/<strong>jquery/3.6.0/jquery.js</strong></a>   后面地址要按照依赖里面的包路径</p>
<h4 id="3-欢迎页与小图标"><a href="#3-欢迎页与小图标" class="headerlink" title="3. 欢迎页与小图标"></a>3. 欢迎页与小图标</h4><ul>
<li>SpringBoot支持从静态资源直接访问欢迎页，或者从Controller层获取</li>
<li>将index.html文件放在静态资源目录下面即可<ul>
<li>可以配置静态资源路径</li>
<li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致welcome page功能失效</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>小图标favicon.ico文件放在静态资源目录下面即可</li>
<li>与欢迎页类似</li>
<li>最新springboot版本已经移除对小图标直接访问的介绍</li>
</ul>
<h4 id="4-静态资源源码分析"><a href="#4-静态资源源码分析" class="headerlink" title="4. 静态资源源码分析"></a>4. 静态资源源码分析</h4><ul>
<li><p>SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</p>
</li>
<li><p>SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="string">禁用所有静态资源规则</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-请求参数处理"><a href="#2-3-请求参数处理" class="headerlink" title="2.3 请求参数处理"></a>2.3 请求参数处理</h3><h4 id="1-Rest风格"><a href="#1-Rest风格" class="headerlink" title="1. Rest风格"></a>1. Rest风格</h4><ul>
<li><p><em>以前：</em><em>/getUser</em>  <em>获取用户</em>    <em>/deleteUser</em> <em>删除用户</em>   <em>/editUser</em>  <em>修改用户</em>      <em>/saveUser</em> <em>保存用户</em></p>
</li>
<li><p><em>现在： /user</em>    *GET-*<em>获取用户</em>    *DELETE-*<em>删除用户</em>     *PUT-*<em>修改用户</em>      *POST-*<em>保存用户</em></p>
</li>
<li><p>使用如下：</p>
<ul>
<li><p>~~~Java<br>@RestController<br>public class HelloController {</p>
<pre><code>//    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)
@GetMapping(&quot;/user&quot;)
public String getUser()&#123;

    return &quot;GET-张三&quot;;
&#125;

//    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)
@PostMapping(&quot;/user&quot;)
public String saveUser()&#123;
    return &quot;POST-张三&quot;;
&#125;


//    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)
@PutMapping(&quot;/user&quot;)
public String putUser()&#123;

    return &quot;PUT-张三&quot;;
&#125;

@DeleteMapping(&quot;/user&quot;)
</code></pre>
<p>//    @RequestMapping(value = “/user”,method = RequestMethod.DELETE)</p>
<pre><code>public String deleteUser()&#123;
    return &quot;DELETE-张三&quot;;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ~~~html</span><br><span class="line">  测试REST风格；</span><br><span class="line">  &lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt;</span><br><span class="line">      &lt;input value=&quot;REST-GET 提交&quot; type=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      &lt;input value=&quot;REST-POST 提交&quot; type=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;delete&quot;/&gt;</span><br><span class="line">      &lt;input name=&quot;_m&quot; type=&quot;hidden&quot; value=&quot;delete&quot;/&gt;</span><br><span class="line">      &lt;input value=&quot;REST-DELETE 提交&quot; type=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot;/&gt;</span><br><span class="line">      &lt;input value=&quot;REST-PUT 提交&quot; type=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>get和post 可以直接识别，其他的不行</p>
</li>
<li><p>其他的需要写成post，加上<input name="_method" type="hidden" value="PUT"/>，源码如下</p>
<p><img src="/SpringBoot-2-02.assets/image-20210714181616569.png" alt="image-20210714181616569"></p>
</li>
</ul>
</li>
<li><p>使用Rest风格需要手动开启</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能，默认是false</span></span><br></pre></td></tr></table></figure></li>
<li><p>Rest原理（<strong>表单提交</strong>要使用REST的时候）</p>
<ul>
<li>表单提交会带上**_method=PUT**</li>
<li><strong>请求过来被</strong>HiddenHttpMethodFilter拦截<ul>
<li>请求是否正常，并且是POST</li>
<li>获取到**_method**的值。</li>
<li>兼容以下请求；<strong>PUT</strong>.<strong>DELETE</strong>.<strong>PATCH</strong></li>
<li><strong>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</strong></li>
<li><strong>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用</strong>requesWrapper的。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Rest使用客户端工具，</strong></p>
<ul>
<li>如PostMan直接发送Put、delete等方式请求，无需Filter。</li>
</ul>
</li>
<li><p>拓展，修改默认的_method</p>
<ul>
<li>自己重写配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> /*<span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>*/ </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HiddenHttpMethodFilter methodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-请求映射原理"><a href="#2-请求映射原理" class="headerlink" title="2. 请求映射原理"></a>2. 请求映射原理</h4><p>SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet–&gt;doDispatch（）</p>
<p><img src="/SpringBoot-2-02.assets/1603181171918-b8acfb93-4914-4208-9943-b37610e93864.png" alt="image.png"></p>
<h4 id="3-常用的注解"><a href="#3-常用的注解" class="headerlink" title="3. 常用的注解"></a>3. 常用的注解</h4><ul>
<li><p>@PathVariable 路径变量    @PathVariable(“id”) Integer id,</p>
<ul>
<li>路径变量和请求参数的不同</li>
<li>路径变量：/{id}</li>
<li>请求参数：?age=18</li>
</ul>
</li>
<li><p>@RequestHeader 请求头 @RequestHeader(“User-Agent”) String userAgent</p>
<ul>
<li><img src="/SpringBoot-2-02.assets/image-20210715185208518.png" alt="image-20210715185208518"></li>
</ul>
</li>
<li><p>@RequestParam 请求参数 @RequestParam(“age”) Integer age,</p>
</li>
<li><p>@CookieValue 获取cookie值  @CookieValue(“<strong>Pycharm-40937f47”</strong>) Cookie cookie</p>
<ul>
<li><img src="/SpringBoot-2-02.assets/image-20210715185526781.png" alt="image-20210715185526781"></li>
</ul>
</li>
<li><p>@RequestBody 获取请求体[必须为POST]  @RequestBody String content</p>
</li>
<li><p>上述五个注解，除了可以单独获取其中的参数，也可以使用**Map&lt;String,String&gt;**方式来获取整个map</p>
</li>
</ul>
<ul>
<li><p>@RequestAttribute    获取request域属性 @RequestAttribute(value = “msg”,required = false) String msg</p>
<ul>
<li>required的取值如下：</li>
<li>Both the MVC namespace and the MVC Java configuration keep this flag set to <code>false</code>, to maintain backwards compatibility. However, for new applications, we recommend setting it to <code>true</code>.</li>
<li>MVC 命名空间和 MVC Java 配置都将此标志设置为<code>false</code>，以保持向后兼容性。但是，对于新应用程序，我们建议将其设置为<code>true</code>.</li>
</ul>
</li>
<li><p>@MatrixVariable  矩阵变量  @MatrixVariable(“low”) Integer low</p>
<ul>
<li><p>语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd</p>
</li>
<li><p>SpringBoot默认是禁用了矩阵变量的功能</p>
</li>
<li><p>手动开启：原理。</p>
<ul>
<li><p>对于路径的处理。UrlPathHelper进行解析。</p>
</li>
<li><p>removeSemicolonContent（移除分号内容）支持矩阵变量的</p>
</li>
<li><p>~~~java<br>@Override</p>
<pre><code>        public void configurePathMatch(PathMatchConfigurer configurer) &#123;
            UrlPathHelper urlPathHelper = new UrlPathHelper();
            // 不移除；后面的内容。矩阵变量功能就可以生效
            urlPathHelper.setRemoveSemicolonContent(false);
            configurer.setUrlPathHelper(urlPathHelper);
        &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 矩阵变量必须有url路径变量才能被解析</span><br><span class="line"></span><br><span class="line">- ~~~Java</span><br><span class="line">  @RestController</span><br><span class="line">  public class ParameterTestController &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      //  car/2/owner/zhangsan</span><br><span class="line">      @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br><span class="line">      public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id,</span><br><span class="line">                                       @PathVariable(&quot;username&quot;) String name,</span><br><span class="line">                                       @PathVariable Map&lt;String,String&gt; pv,</span><br><span class="line">                                       @RequestHeader(&quot;User-Agent&quot;) String userAgent,</span><br><span class="line">                                       @RequestHeader Map&lt;String,String&gt; header,</span><br><span class="line">                                       @RequestParam(&quot;age&quot;) Integer age,</span><br><span class="line">                                       @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters,</span><br><span class="line">                                       @RequestParam Map&lt;String,String&gt; params,</span><br><span class="line">                                       @CookieValue(&quot;Pycharm-40937f47&quot;) String _ga,</span><br><span class="line">                                       @CookieValue(&quot;Pycharm-40937f47&quot;) Cookie cookie)&#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  //        map.put(&quot;id&quot;,id);</span><br><span class="line">  //        map.put(&quot;name&quot;,name);</span><br><span class="line">  //        map.put(&quot;pv&quot;,pv);</span><br><span class="line">          map.put(&quot;userAgent&quot;,userAgent);</span><br><span class="line">          map.put(&quot;headers&quot;,header);</span><br><span class="line">          map.put(&quot;age&quot;,age);</span><br><span class="line">          map.put(&quot;inters&quot;,inters);</span><br><span class="line">          map.put(&quot;params&quot;,params);</span><br><span class="line">          map.put(&quot;_ga&quot;,_ga);</span><br><span class="line">          System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue());</span><br><span class="line">          return map;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      @PostMapping(&quot;/save&quot;)</span><br><span class="line">      public Map postMethod(@RequestBody String content)&#123;</span><br><span class="line">          Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">          map.put(&quot;content&quot;,content);</span><br><span class="line">          return map;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd</span><br><span class="line">      //2、SpringBoot默认是禁用了矩阵变量的功能</span><br><span class="line">      //      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。</span><br><span class="line">      //              removeSemicolonContent（移除分号内容）支持矩阵变量的</span><br><span class="line">      //3、矩阵变量必须有url路径变量才能被解析</span><br><span class="line">      @GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span><br><span class="line">      public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low,</span><br><span class="line">                          @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand,</span><br><span class="line">                          @PathVariable(&quot;path&quot;) String path)&#123;</span><br><span class="line">          Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">          map.put(&quot;low&quot;,low);</span><br><span class="line">          map.put(&quot;brand&quot;,brand);</span><br><span class="line">          map.put(&quot;path&quot;,path);</span><br><span class="line">          return map;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      // /boss/1;age=20/2;age=10</span><br><span class="line">  </span><br><span class="line">      @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)</span><br><span class="line">      public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge,</span><br><span class="line">                      @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123;</span><br><span class="line">          Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">          map.put(&quot;bossAge&quot;,bossAge);</span><br><span class="line">          map.put(&quot;empAge&quot;,empAge);</span><br><span class="line">          return map;</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-Servlet-API"><a href="#4-Servlet-API" class="headerlink" title="4. Servlet API"></a>4. Servlet API</h4><p>WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId</p>
<p><strong>ServletRequestMethodArgumentResolver  以上的部分参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">		<span class="keyword">return</span> (WebRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">				ServletRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">				MultipartRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">				HttpSession.class.isAssignableFrom(paramType) ||</span><br><span class="line">				(pushBuilder != <span class="keyword">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||</span><br><span class="line">				Principal.class.isAssignableFrom(paramType) ||</span><br><span class="line">				InputStream.class.isAssignableFrom(paramType) ||</span><br><span class="line">				Reader.class.isAssignableFrom(paramType) ||</span><br><span class="line">				HttpMethod.class == paramType ||</span><br><span class="line">				Locale.class == paramType ||</span><br><span class="line">				TimeZone.class == paramType ||</span><br><span class="line">				ZoneId.class == paramType);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-复杂参数"><a href="#5-复杂参数" class="headerlink" title="5. 复杂参数"></a>5. 复杂参数</h4><p><strong>Map</strong>、<strong>Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、</strong>Errors/BindingResult、<strong>RedirectAttributes（ 重定向携带数据）</strong>、<strong>ServletResponse（response）</strong>、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map,  Model model, HttpServletRequest request 都是可以给request域中放数据，</span><br><span class="line">request.getAttribute();</span><br></pre></td></tr></table></figure>

<h4 id="6-pojo封装"><a href="#6-pojo封装" class="headerlink" title="6. pojo封装"></a>6. pojo封装</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveuser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">saveuser</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以自定义类型参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addConverter(<span class="keyword">new</span> Converter&lt;String, Pet&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Pet <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 啊猫,3</span></span><br><span class="line">                        <span class="keyword">if</span>(!StringUtils.isEmpty(source))&#123;</span><br><span class="line">                            Pet pet = <span class="keyword">new</span> Pet();</span><br><span class="line">                            String[] split = source.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                            pet.setName(split[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//                            pet.setAge(Integer.parseInt(split[1]));</span></span><br><span class="line">                            pet.setAge(split[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">return</span> pet;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-数据响应"><a href="#2-4-数据响应" class="headerlink" title="2.4 数据响应"></a>2.4 数据响应</h3><h4 id="1-响应JSON数据"><a href="#1-响应JSON数据" class="headerlink" title="1. 响应JSON数据"></a>1. 响应JSON数据</h4><ul>
<li>主要通过jackson.jar+@ResponseBody</li>
<li>spring-boot-starter-web场景自动引入了json场景</li>
</ul>
<h4 id="2-springmvc支持响应的数据类型"><a href="#2-springmvc支持响应的数据类型" class="headerlink" title="2. springmvc支持响应的数据类型"></a>2. springmvc支持响应的数据类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ModelAndView</span><br><span class="line">Model</span><br><span class="line">View</span><br><span class="line">ResponseEntity </span><br><span class="line">ResponseBodyEmitter</span><br><span class="line">StreamingResponseBody</span><br><span class="line">HttpEntity</span><br><span class="line">HttpHeaders</span><br><span class="line">Callable</span><br><span class="line">DeferredResult</span><br><span class="line">ListenableFuture</span><br><span class="line">CompletionStage</span><br><span class="line">WebAsyncTask</span><br><span class="line">有 <span class="meta">@ModelAttribute</span> 且为对象类型的</span><br><span class="line"><span class="meta">@ResponseBody</span> 注解 ---&gt; RequestResponseBodyMethodProcessor；</span><br></pre></td></tr></table></figure>



<h3 id="2-5-内容协商"><a href="#2-5-内容协商" class="headerlink" title="2.5 内容协商"></a>2.5 内容协商</h3><p>根据客户端接收能力不同，返回不同媒体类型的数据。</p>
<ol>
<li><p>首先导入相应依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>开启浏览器参数方式内容协商功能</p>
<p>为了方便内容协商，开启基于请求参数的内容协商功能。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">    	<span class="attr">contentnegotiation:</span></span><br><span class="line">      		<span class="attr">favor-parameter:</span> <span class="literal">true</span>  <span class="comment">#开启请求参数内容协商模式</span></span><br></pre></td></tr></table></figure>

<p>发送请求：<a href="http://localhost:8080/test/person?format=json">http://localhost:8080/test/person?format=json</a></p>
<p>​                   <a href="http://localhost:8080/test/person?format=xml">http://localhost:8080/test/person?format=xml</a></p>
</li>
<li><p>内容协商分为基于请求头和基于请求参数两种</p>
<p><img src="/SpringBoot-2-02.assets/1605230907471-b0ed34bc-6782-40e7-84b7-615726312f01.png" alt="image.png"></p>
</li>
<li><p>自定义MessageConverter</p>
<ul>
<li><p>~~~java<br>/**</p>
<pre><code>         * 自定义内容协商策略
         * @param configurer
         */
        @Override
        public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;
            //Map&lt;String, MediaType&gt; mediaTypes
            Map&lt;String, MediaType&gt; mediaTypes = new HashMap&lt;&gt;();
            mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON);
            mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);
            mediaTypes.put(&quot;gg&quot;,MediaType.parseMediaType(&quot;application/x-guigu&quot;));
            //指定支持解析哪些参数对应的哪些媒体类型
            ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);
</code></pre>
<p>//                parameterStrategy.setParameterName(“ff”);</p>
<pre><code>            //保证之前请求头的方式不失效
            HeaderContentNegotiationStrategy headeStrategy = new HeaderContentNegotiationStrategy();

            configurer.strategies(Arrays.asList(parameterStrategy,headeStrategy));
        &#125;

        @Override
        public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
            converters.add(new GuiguMessageConverter());
        &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ~~~java</span><br><span class="line">  /**</span><br><span class="line">   * 自定义的Converter</span><br><span class="line">   */</span><br><span class="line">  public class GuiguMessageConverter implements HttpMessageConverter&lt;Person&gt; &#123;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType) &#123;</span><br><span class="line">          return clazz.isAssignableFrom(Person.class);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 服务器要统计所有MessageConverter都能写出哪些内容类型</span><br><span class="line">       *</span><br><span class="line">       * application/x-guigu</span><br><span class="line">       * @return</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public List&lt;MediaType&gt; getSupportedMediaTypes() &#123;</span><br><span class="line">          return MediaType.parseMediaTypes(&quot;application/x-guigu&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public Person read(Class&lt;? extends Person&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123;</span><br><span class="line">          //自定义协议数据的写出</span><br><span class="line">          String data = person.getUserName()+&quot;;&quot;+person.getAge()+&quot;;&quot;+person.getBirth();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          //写出去</span><br><span class="line">          OutputStream body = outputMessage.getBody();</span><br><span class="line">          body.write(data.getBytes());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。</strong>比如上面添加自定义的请求参数协议时，请求头方式失效。</p>
<p><strong>上述功能除了我们完全自定义外？SpringBoot有没有为我们提供基于配置文件的快速修改媒体类型功能？怎么配置呢？【提示：参照SpringBoot官方文档web开发内容协商章节】</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-6-视图解析"><a href="#2-6-视图解析" class="headerlink" title="2.6 视图解析"></a>2.6 视图解析</h3><ul>
<li>视图解析流程</li>
</ul>
<h3 id="2-7-模板引擎-Thymeleaf"><a href="#2-7-模板引擎-Thymeleaf" class="headerlink" title="2.7 模板引擎-Thymeleaf"></a>2.7 模板引擎-Thymeleaf</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>springboot不支持jsp页面（可通过额外配置），支持模板引擎thymeleaf。推荐前后端分离开发。</p>
<p>官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>官方文档：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a></p>
<h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h4><ul>
<li><p>引入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>已经自动配置好了thymeleaf</p>
<ul>
<li><p>1、所有thymeleaf的配置值都在 ThymeleafProperties</p>
</li>
<li><p>2、配置好了 <strong>SpringTemplateEngine</strong> </p>
</li>
<li><p><strong>3、配好了</strong> <strong>ThymeleafViewResolver</strong> </p>
</li>
<li><p>4、我们只需要直接开发页面</p>
</li>
<li><p>~~~java</p>
<pre><code>private String prefix = &quot;classpath:/templates/&quot;;
private String suffix = &quot;.html&quot;;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 编写html文件，记得加上  xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br><span class="line"></span><br><span class="line">  ~~~html</span><br><span class="line">  &lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">      &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;哈哈&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;</span><br><span class="line">      &lt;a href=&quot;www.atguigu.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;去百度&lt;/a&gt;  &lt;br/&gt;</span><br><span class="line">      &lt;a href=&quot;www.atguigu.com&quot; th:href=&quot;@&#123;link&#125;&quot;&gt;去百度2&lt;/a&gt;</span><br><span class="line">  &lt;/h2&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编写controller层</p>
</li>
<li><p>注：可以在配置文件给所有路径加上前缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给页面路径加前缀</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/study</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-后台管理系统练习"><a href="#3-后台管理系统练习" class="headerlink" title="3. 后台管理系统练习"></a>3. 后台管理系统练习</h4><ul>
<li><p>项目创建</p>
<ul>
<li>导入thymeleaf、web-starter、lombok等</li>
</ul>
</li>
<li><p>添加静态资源放在static目录下面</p>
</li>
<li><p>已经写好的前端页面放在templates目录下面</p>
<ul>
<li>html文件记得加上 xmlns:th=”<a href="http://www.thymeleaf.org&quot;/">http://www.thymeleaf.org&quot;</a></li>
<li>路径构建th:action=”@{/login}”</li>
<li>标签里面的写法：**[[${}]]**，比如[[${session.loginUser.userName}]]</li>
</ul>
</li>
<li><p>编写简单逻辑的登录controller</p>
</li>
<li><p>抽取公共页面，减少代码冗余</p>
<ul>
<li>编写公共页面，包括重复使用的页面，样式等</li>
<li>公共部分中有两种方式来标识<ul>
<li>th:fragment=”commonheader”    对应页面th:replace=”common :: <strong>commonheader</strong>“</li>
<li>直接使用id选择器    对应页面th:replace=”common :: <strong>#commonheader</strong>“</li>
</ul>
</li>
<li>调用公共部分三种方式<ul>
<li><code>th:insert</code> 是最简单的：它会简单地插入指定的片段作为其宿主标签的主体。</li>
<li><code>th:replace</code>实际上用指定的片段替换其主机标记。（推荐）</li>
<li><code>th:include</code>与 类似<code>th:insert</code>，但它不插入片段，而是仅插入此片段的<em>内容</em>。（3.0开始不推荐使用）</li>
<li><img src="/SpringBoot-2-02.assets/image-20210720183500471.png" alt="image-20210720183500471"><ul>
<li>注：在抽取公共页面时，不要改变原来部分或者样式的前后位置（比如最下面的js样式），可能会出错！！！</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>thymeleaf中表格的遍历</p>
<ul>
<li><p>先传入几个测试数据</p>
</li>
<li><p>```Java<br>List<User> users = Arrays.asList(new User(“zhangsan”, “123456”),</p>
<pre><code>    new User(&quot;lisi&quot;, &quot;123444&quot;),
    new User(&quot;haha&quot;, &quot;aaaaa&quot;),
    new User(&quot;hehe &quot;, &quot;aaddd&quot;));
</code></pre>
<p>model.addAttribute(“users”,users);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 遍历语法 th:each=&quot;user:$&#123;users&#125;，user里面有具体每个用户的数据</span><br><span class="line"></span><br><span class="line">- 可在user后面用逗号隔开，添加一个状态码，可以查看遍历的index,count等</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;users&#125;&quot;&gt;</span><br><span class="line">      &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;Trident&lt;/td&gt;</span><br><span class="line">      &lt;td th:text=&quot;$&#123;user.userName&#125;&quot;&gt;Internet</span><br><span class="line">          Explorer 4.0&lt;/td&gt;</span><br><span class="line">      &lt;td th:text=&quot;$&#123;user.password&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/tr&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-8-拦截器"><a href="#2-8-拦截器" class="headerlink" title="2.8 拦截器"></a>2.8 拦截器</h3><h4 id="1-springboot中拦截器的使用"><a href="#1-springboot中拦截器的使用" class="headerlink" title="1. springboot中拦截器的使用"></a>1. springboot中拦截器的使用</h4><ul>
<li><p>实现HandlerInterceptor接口，这里主要是实现登录拦截</p>
</li>
<li><p>~~~java<br>/**</p>
<ul>
<li><p>登录检查</p>
</li>
<li><p>1、配置好拦截器要拦截哪些请求</p>
</li>
<li><p>2、把这些配置放在容器中</p>
</li>
<li><p>/<br>@Slf4j<br>public class LoginInterceptor implements HandlerInterceptor {<br>  /**</p>
<ul>
<li><p>目标方法执行之前</p>
</li>
<li><p>@param request</p>
</li>
<li><p>@param response</p>
</li>
<li><p>@param handler</p>
</li>
<li><p>@return</p>
</li>
<li><p>@throws Exception</p>
</li>
<li><p>/<br>@Override<br>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {<br>  //利用Lombok提供的日志功能查看拦截了哪些路径<br>  String requestURI = request.getRequestURI();<br>  log.info(“preHandle拦截的请求路径是{}”,requestURI);</p>
<p>  //登陆检查<br>  HttpSession session = request.getSession();<br>  Object loginUser = session.getAttribute(“loginUser”);</p>
<p>  if (loginUser != null){</p>
<pre><code>  //放行
  return true;
</code></pre>
<p>  }else{</p>
<pre><code>  //拦截，跳转到登录页
  //这里不能用session，前端接收不到
  request.setAttribute(&quot;msg&quot;,&quot;请登录！&quot;);
  request.getRequestDispatcher(&quot;/&quot;).forward(request,response);
  return false;
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>  //目标方法执行之后<br>  @Override<br>  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {</p>
<pre><code>  log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView);
  HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
</code></pre>
<p>  }</p>
<p>  //页面渲染之后<br>  @Override<br>  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {</p>
<pre><code>  log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex);
  HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 将拦截器注册到容器之中，并且指定拦截规则</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Configuration</span><br><span class="line">  public class AdminWebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">          registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                  .addPathPatterns(&quot;/**&quot;)  //拦截的路径,/**拦截所有路径，包括静态资源</span><br><span class="line">                  //放行的资源路径，不能直接写/static，找不到因为页面编写没有带static</span><br><span class="line">                  .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">#### 2. 拦截器原理分析</span><br><span class="line"></span><br><span class="line">1、根据当前请求，找到**HandlerExecutionChain【**可以处理请求的handler以及handler的所有 拦截器】</span><br><span class="line"></span><br><span class="line">2、先来**顺序执行** 所有拦截器的 preHandle方法</span><br><span class="line"></span><br><span class="line">- 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle</span><br><span class="line">- 2、**如果当前拦截器返回为false。直接    倒序执行所有已经执行了的拦截器的  afterCompletion；**</span><br><span class="line"></span><br><span class="line">**3、如果任何一个拦截器返回false。直接跳出不执行目标方法**</span><br><span class="line"></span><br><span class="line">**4、所有拦截器都返回True。执行目标方法**</span><br><span class="line"></span><br><span class="line">**5、倒序执行所有拦截器的postHandle方法。**</span><br><span class="line"></span><br><span class="line">**6、前面的步骤有任何异常都会直接倒序触发** afterCompletion</span><br><span class="line"></span><br><span class="line">7、页面成功渲染完成以后，也会倒序触发 afterCompletion</span><br><span class="line"></span><br><span class="line">![image.png](SpringBoot-2-02.assets/1605765121071-64cfc649-4892-49a3-ac08-88b52fb4286f.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.9 文件上传</span><br><span class="line"></span><br><span class="line">#### 1. 文件上传的步骤</span><br><span class="line"></span><br><span class="line">- 页面中修改form表单</span><br><span class="line"></span><br><span class="line">- method=&quot;post&quot; th:action=&quot;@&#123;/upload&#125;&quot; enctype=&quot;multipart/form-data&quot;</span><br><span class="line"></span><br><span class="line">  - enctype=&quot;multipart/form-data&quot; ，multipart/form-data是指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思，可提供文件上传功能</span><br><span class="line"></span><br><span class="line">- ```html</span><br><span class="line">  &lt;!--multiple代表上传多文件--&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;photos&quot; multiple&gt;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- controller层通过 MultipartFile 自动封装上传过来的文件</span><br><span class="line"></span><br><span class="line">- @RequestPart</span><br><span class="line"></span><br><span class="line">  - 1 @RequestParam适用于name-value表单字段，而@RequestPart经常被用于处理复杂内容（例如JSON, XML） </span><br><span class="line">  - 2 当方法的参数类型不是String或者原生的MultipartFile / Part，@RequstParam需要注册并使用 Converter or PropertyEditor 进行类型转换，而 RequestPart 可通过请求体中的“Content-Type“进行使用 HttpMessageConverters转换</span><br><span class="line"></span><br><span class="line">- headImg.transferTo方法可将文件上传到指定路径</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @PostMapping(&quot;/upload&quot;)</span><br><span class="line">  public String upload(@RequestParam String email,</span><br><span class="line">                       @RequestParam String password,</span><br><span class="line">                       @RequestPart MultipartFile headImg,</span><br><span class="line">                       @RequestPart MultipartFile[] photos)throws IOException &#123;</span><br><span class="line">      log.info(&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;,</span><br><span class="line">              email,password,headImg.getSize(),photos.length);</span><br><span class="line">  </span><br><span class="line">      if(!headImg.isEmpty())&#123;</span><br><span class="line">          //保存到文件服务器，OSS服务器</span><br><span class="line">          String originalFilename = headImg.getOriginalFilename();</span><br><span class="line">          //需要抛出异常</span><br><span class="line">          headImg.transferTo(new File(&quot;D:\\test\\&quot;+originalFilename));</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      if(photos.length &gt; 0)&#123;</span><br><span class="line">          for (MultipartFile photo : photos) &#123;</span><br><span class="line">              if(!photo.isEmpty())&#123;</span><br><span class="line">                  String originalFilename = photo.getOriginalFilename();</span><br><span class="line">                  photo.transferTo(new File(&quot;D:\\test\\&quot;+originalFilename));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      return &quot;main&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">#### 2. 文件上传原理分析</span><br><span class="line"></span><br><span class="line">**文件上传自动配置类-MultipartAutoConfiguration-**MultipartProperties</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.10 页面异常处理</span><br><span class="line"></span><br><span class="line">#### 1. 官网描述</span><br><span class="line"></span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.error-handling</span><br><span class="line"></span><br><span class="line">#### 2. 默认规则</span><br><span class="line"></span><br><span class="line">- 默认情况下，Spring Boot 提供了一个`/error`以合理方式处理所有错误的映射</span><br><span class="line"></span><br><span class="line">- 对于机器客户端，它会生成包含错误详细信息、HTTP 状态和异常消息的 JSON 响应</span><br><span class="line"></span><br><span class="line">- 对于浏览器客户端，有一个“whitelabel”错误视图，它以 HTML 格式呈现相同的数据（要自定义它，添加一个`View`解析为 的`error`）如下：![image.png](SpringBoot-2-02.assets/1606024616835-bc491bf0-c3b1-4ac3-b886-d4ff3c9874ce.png)</span><br><span class="line"></span><br><span class="line">- 可以将自定义的404.html，5xx.html页面放在下面目录下，当发生相应错误会自动解析</span><br><span class="line"></span><br><span class="line">  - 5xx代表5开头的所有错误</span><br><span class="line">  - 4xx代表4开头的所有错误</span><br><span class="line"></span><br><span class="line">  ```</span><br><span class="line">   resources/public/error/404.html</span><br><span class="line">   resources/templates/error/404.html</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">- 可以在页面中拿到下面的信息![image-20210721183513076](SpringBoot-2-02.assets/image-20210721183513076.png)</span><br><span class="line"></span><br><span class="line">#### 3. 异常处理自动配置原理</span><br><span class="line"></span><br><span class="line">- **ErrorMvcAutoConfiguration**</span><br><span class="line"></span><br><span class="line">  - **容器中的组件：类型：DefaultErrorAttributes -&gt;** **id：errorAttributes**</span><br><span class="line">    - **public class** **DefaultErrorAttributes** **implements** **ErrorAttributes**, **HandlerExceptionResolver**</span><br><span class="line">    - **DefaultErrorAttributes**：定义错误页面中可以包含哪些数据。</span><br><span class="line">  - **容器中的组件：类型：**BasicErrorController --&gt; id：basicErrorController（json+白页 适配响应）</span><br><span class="line">    - **处理默认** **/error 路径的请求；页面响应** **new** ModelAndView(**&quot;error&quot;**, model)；</span><br><span class="line">    - **容器中有组件 View**-&gt;**id是error**；（响应默认错误页）</span><br><span class="line">    - 容器中放组件 **BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。**</span><br><span class="line"></span><br><span class="line">  - **容器中的组件：**类型：**DefaultErrorViewResolver -&gt; id：**conventionErrorViewResolver</span><br><span class="line"></span><br><span class="line">    - 如果发生错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面</span><br><span class="line"></span><br><span class="line">    - error/404、5xx.html</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">#### 4. 定制错误处理逻辑</span><br><span class="line"></span><br><span class="line">1. 自定义错误页</span><br><span class="line"></span><br><span class="line">   - error/404.html   error/5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页</span><br><span class="line">   - 如果5xx.html，4xx.html这些页面本身有编码错误执行不了，会出现![image-20210722163501060](SpringBoot-2-02.assets/image-20210722163501060.png)</span><br><span class="line"></span><br><span class="line">2. @ControllerAdvice+@ExceptionHandler处理全局异常</span><br><span class="line"></span><br><span class="line">   - 底层是 **ExceptionHandlerExceptionResolver 支持的**</span><br><span class="line"></span><br><span class="line">   - ~~~java</span><br><span class="line">     /**</span><br><span class="line">      * 处理整个web controller的异常</span><br><span class="line">      * ArithmeticException数学异常，NullPointerException空指针异常</span><br><span class="line">      */</span><br><span class="line">     @Slf4j</span><br><span class="line">     @ControllerAdvice</span><br><span class="line">     public class GlobalExceptionHandler &#123;</span><br><span class="line">     </span><br><span class="line">         @ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;)  //处理异常</span><br><span class="line">         public String handleArithException(Exception e)&#123;</span><br><span class="line">     </span><br><span class="line">             log.error(&quot;异常是：&#123;&#125;&quot;,e);</span><br><span class="line">             return &quot;login&quot;; //视图地址</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>@ResponseStatus+自定义异常 </p>
<ul>
<li><p>底层是 <strong>ResponseStatusExceptionResolver ，把responsestatus注解的信息底层调用</strong> <strong>response.sendError(statusCode, resolvedReason)；</strong></p>
</li>
<li><p><strong>tomcat发送的/error</strong></p>
</li>
<li><p>```java<br>/**</p>
<ul>
<li><p>自定义一个异常</p>
</li>
<li><p>/<br>@ResponseStatus(value= HttpStatus.FORBIDDEN,reason = “用户数量太多”)<br>public class UserTooManyException extends RuntimeException {</p>
<p>  //无参<br>  public  UserTooManyException(){</p>
<p>  }</p>
<p>  //有参<br>  public  UserTooManyException(String message){</p>
<pre><code>  super(message);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>//自己抛出一个异常</p>
<pre><code>    if(users.size()&gt;3)&#123;
        throw new UserTooManyException();
    &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. Spring底层的异常</span><br><span class="line"></span><br><span class="line">   - 如 参数类型转换异常；**DefaultHandlerExceptionResolver 处理框架底层的异常。**</span><br><span class="line">   - response.sendError(HttpServletResponse.**SC_BAD_REQUEST**, ex.getMessage()); </span><br><span class="line"></span><br><span class="line">5. 自定义实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则</span><br><span class="line"></span><br><span class="line">   - ```Java</span><br><span class="line">     @Order(value= Ordered.HIGHEST_PRECEDENCE)  //优先级，数字越小优先级越高</span><br><span class="line">     @Component</span><br><span class="line">     public class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public ModelAndView resolveException(HttpServletRequest request,</span><br><span class="line">                                              HttpServletResponse response,</span><br><span class="line">                                              Object handler, Exception ex) &#123;</span><br><span class="line">     </span><br><span class="line">             try &#123;</span><br><span class="line">                 response.sendError(511,&quot;我喜欢的错误&quot;);</span><br><span class="line">             &#125; catch (IOException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">             return new ModelAndView();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>提高了优先级，大部分页面出现异常都会被该自定义处理（404页面不行）</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-11-web原生组件注入"><a href="#2-11-web原生组件注入" class="headerlink" title="2.11 web原生组件注入"></a>2.11 web原生组件注入</h3><h4 id="1-官方文档"><a href="#1-官方文档" class="headerlink" title="1. 官方文档"></a>1. 官方文档</h4><ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.embedded-container.servlets-filters-listeners">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.embedded-container.servlets-filters-listeners</a></li>
</ul>
<h4 id="2-使用Servlet-API（推荐使用）"><a href="#2-使用Servlet-API（推荐使用）" class="headerlink" title="2. 使用Servlet API（推荐使用）"></a>2. 使用Servlet API（推荐使用）</h4><ul>
<li><p>可以使用注解方式实现注入</p>
</li>
<li><p>使用之前需要在主程序加上注解，扫描指定包    @ServletComponentScan(basePackages = “com.wjj”)</p>
<ul>
<li><p>servlet组件 ，直接响应，不会经过拦截器 <strong>@WebServlet(urlPatterns = “/my”)</strong></p>
</li>
<li><p>```java<br>@WebServlet(urlPatterns = “/my”)<br>public class MyServlet extends HttpServlet {</p>
<pre><code>@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
    resp.getWriter().write(&quot;66&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- filter组件，@WebFilter(urlPatterns = &quot;/css/*&quot;)</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Slf4j</span><br><span class="line">  @WebFilter(urlPatterns = &quot;/css/*&quot;) //  /*是servlet中的写法，/**是spring中的写法</span><br><span class="line">  public class MyFilter implements Filter &#123;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">          log.info(&quot;Filter初始化&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void destroy() &#123;</span><br><span class="line">          log.info(&quot;Filter销毁&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">          log.info(&quot;Filter工作&quot;);</span><br><span class="line">          filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>listener组件，@WebListener</p>
</li>
<li><p>```Java<br>@Slf4j<br>@WebListener<br>public class MyServletContextListener implements ServletContextListener {</p>
<pre><code>@Override
public void contextInitialized(ServletContextEvent sce) &#123;
    log.info(&quot;监听到项目初始化&quot;);
&#125;

@Override
public void contextDestroyed(ServletContextEvent sce) &#123;
    log.info(&quot;监听到项目销毁&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- servlet不经过拦截器的原因：</span><br><span class="line"></span><br><span class="line">  - 容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是 **spring.mvc。**</span><br><span class="line">  - **通过** **ServletRegistrationBean**&lt;DispatcherServlet&gt; 把 DispatcherServlet  配置进来。</span><br><span class="line">  - 默认映射的是 / 路径</span><br><span class="line">  - 我们这里的servlet路径是/my，Tomcat-Servlet在多个servlet都能处理同一路径时，会采用精度优先的原则</span><br><span class="line">  - 因此就不会通过spring中设置的拦截器</span><br><span class="line"></span><br><span class="line">#### 2. 使用RegistrationBean方式</span><br><span class="line"></span><br><span class="line">- ServletRegistrationBean，FilterRegistrationBean以及ServletListenerRegistrationBean注入容器</span><br><span class="line"></span><br><span class="line">- ```Java</span><br><span class="line">  //(proxyBeanMethods = true) 保证组件依赖始终是单实例，默认就是true</span><br><span class="line">  @Configuration</span><br><span class="line">  public class MyRegistConfig &#123;</span><br><span class="line">  </span><br><span class="line">      @Bean</span><br><span class="line">      public ServletRegistrationBean myServlet()&#123;</span><br><span class="line">          MyServlet myServlet = new MyServlet();</span><br><span class="line">  </span><br><span class="line">          return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      @Bean</span><br><span class="line">      public FilterRegistrationBean myFilter()&#123;</span><br><span class="line">  </span><br><span class="line">          MyFilter myFilter = new MyFilter();</span><br><span class="line">  //        return new FilterRegistrationBean(myFilter,myServlet());  直接过滤myServlet()中的路径</span><br><span class="line">          FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);</span><br><span class="line">          filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;));</span><br><span class="line">          return filterRegistrationBean;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Bean</span><br><span class="line">      public ServletListenerRegistrationBean myListener()&#123;</span><br><span class="line">          MyServletContextListener myServletContextListener = new MyServletContextListener();</span><br><span class="line">          return new ServletListenerRegistrationBean(myServletContextListener);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-12-嵌入式servlet容器"><a href="#2-12-嵌入式servlet容器" class="headerlink" title="2.12 嵌入式servlet容器"></a>2.12 嵌入式servlet容器</h3><h4 id="1-切换嵌入式Servlet容器"><a href="#1-切换嵌入式Servlet容器" class="headerlink" title="1. 切换嵌入式Servlet容器"></a>1. 切换嵌入式Servlet容器</h4><ul>
<li><p>嵌入式服务器就是指我们不需要额外再去部署服务器，springboot默认为我们提供了</p>
</li>
<li><p>默认支持的webServer<code>Tomcat</code>, <code>Jetty</code>, or <code>Undertow</code></p>
</li>
<li><p>web场景默认导入tomcat</p>
</li>
<li><p>切换方法 </p>
</li>
<li><p>~~~xml</p>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <!--移除默认tomcat-->
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!--添加新的-->
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jetty</artifactId>
        </dependency>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 原理</span><br><span class="line">  - SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat</span><br><span class="line">  - web应用会创建一个web版的ioc容器 `ServletWebServerApplicationContext` </span><br><span class="line">  - `ServletWebServerApplicationContext` 启动的时候寻找 `**ServletWebServerFactory**``（Servlet 的web服务器工厂---&gt; Servlet 的web服务器）` </span><br><span class="line">  - SpringBoot底层默认有很多的WebServer工厂；`TomcatServletWebServerFactory`, `JettyServletWebServerFactory`, or `UndertowServletWebServerFactory`</span><br><span class="line">  - `底层直接会有一个自动配置类。ServletWebServerFactoryAutoConfiguration`</span><br><span class="line">  - `ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration（配置类）`</span><br><span class="line">  - `ServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有 TomcatServletWebServerFactory`</span><br><span class="line">  - `TomcatServletWebServerFactory 创建出Tomcat服务器并启动；TomcatWebServer 的构造器拥有初始化方法initialize---this.tomcat.start();`</span><br><span class="line">  - `内嵌服务器，就是手动把启动服务器的代码调用（tomcat核心jar包存在）`</span><br><span class="line"></span><br><span class="line">#### 2. 定制Servlet容器</span><br><span class="line"></span><br><span class="line">- 实现  **WebServerFactoryCu**stomizer&lt;ConfigurableServletWebServerFactory&gt; </span><br><span class="line"></span><br><span class="line">- 把配置文件的值和`**ServletWebServerFactory 进行绑定**`</span><br><span class="line"></span><br><span class="line">- 修改配置文件 **server.xxx**</span><br><span class="line">- 直接自定义 **ConfigurableServletWebServerFactory** </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**xxxxxCustomizer：定制化器，可以改变xxxx的默认规则**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line">import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void customize(ConfigurableServletWebServerFactory server) &#123;</span><br><span class="line">        server.setPort(9000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.13 定制化配置</span><br><span class="line"></span><br><span class="line">#### 1.定制化的主要方式</span><br><span class="line"></span><br><span class="line">1. **修改配置文件**</span><br><span class="line">   - 直接在application.properties或者application.yml文件中修改</span><br><span class="line">2. **xxxxxCustomizer：定制化器，可以改变xxxx的默认规则**</span><br><span class="line">3. **编写自定义的配置类   xxxConfiguration；+** **@Bean替换、增加容器中默认组件；视图解析器**</span><br><span class="line">4. **Web应用 编写一个配置类实现** **WebMvcConfigurer 即可定制化web功能；+ @Bean给容器中再扩展一些组件**（常用）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Configuration</span><br><span class="line">public class AdminWebConfig implements WebMvcConfigurer</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">5. **@EnableWebMvc + WebMvcConfigurer —— @Bean** </span><br><span class="line"></span><br><span class="line">   - 添加@EnableWebMvc注解会使之前的所有规则失效，比如静态资源，欢迎页等。需要自己全面重新配置</span><br><span class="line"></span><br><span class="line">   - 原理</span><br><span class="line"></span><br><span class="line">     - 1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页.....</span><br><span class="line">     - 2、一旦使用 @EnableWebMvc 、。会 @Import(DelegatingWebMvcConfiguration.**class**)</span><br><span class="line"></span><br><span class="line">     - 3、**DelegatingWebMvcConfiguration** 的 作用，只保证SpringMVC最基本的使用把所有系统中的WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效自动配置了一些非常底层的组件。比如**RequestMappingHandlerMapping**、这些组件依赖的组件都是从容器中获取**public class** DelegatingWebMvcConfiguration **extends** **WebMvcConfigurationSupport**</span><br><span class="line"></span><br><span class="line">     - 4、**WebMvcAutoConfiguration** 里面的配置要能生效 必须  @ConditionalOnMissingBean(**WebMvcConfigurationSupport**.**class**)</span><br><span class="line">     - 5、@EnableWebMvc  导致了 **WebMvcAutoConfiguration  没有生效。**</span><br><span class="line"></span><br><span class="line">#### 2. 一般的原理分析套路</span><br><span class="line"></span><br><span class="line">**场景starter** **- xxxxAutoConfiguration - 导入xxx组件 - 绑定xxxProperties --** **绑定配置文件项** </span><br><span class="line"></span><br><span class="line">- 导入相应的场景</span><br><span class="line">- 找到对应的自动配置文件，命名主要是xxxxAutoConfiguration</span><br><span class="line">- 配置文件里面一般使用@bean导入各种组件</span><br><span class="line">- 组件里的默认属性都跟xxxProperties绑定</span><br><span class="line">- 最后绑定在配置文件之下，我们需要修改只需要改配置文件即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 3.数据访问</span><br><span class="line"></span><br><span class="line">### 3.1 SQL</span><br><span class="line"></span><br><span class="line">#### 1.数据源的自动配置</span><br><span class="line"></span><br><span class="line">- 导入场景依赖</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;SpringBoot-2-02.assets/image-20210723165222136.png&quot; alt=&quot;image-20210723165222136&quot; style=&quot;zoom: 80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  - jdbc场景并没有导入驱动，因为无法判断实际使用的是哪个数据库</span><br><span class="line"></span><br><span class="line">  - 自行导入mysql</span><br><span class="line"></span><br><span class="line">    ~~~xml</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    1.导入之后默认会有一个8版本的</span><br><span class="line">    2.根据自己使用的mysql版本更改</span><br><span class="line">    	1、直接依赖引入具体版本（maven的就近依赖原则）</span><br><span class="line">    	2、重新声明版本（maven的属性的就近优先原则）</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">                &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据库和数据源</p>
<p>1.数据库中存放数据，数据源相当于连接到数据库的一条路径</p>
<p>2.DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池。</p>
<p>3.数据库连接池就是准备一个池子，里面放着很多生成好的Connection，用户请求获得连接，就不需要getConnection,只要从池子里拿一个给他就行了，这样省掉了生成Connection的时间，效率上会有很大提高</p>
</blockquote>
</li>
<li><p>自动配置原理</p>
<ul>
<li><p>自动配置的类</p>
<ul>
<li>DataSourceAutoConfiguration ： 数据源的自动配置<ul>
<li>修改数据源相关的配置：<strong>spring.datasource</strong></li>
<li><strong>数据库连接池的配置，是自己容器中没有DataSource才自动配置的</strong></li>
<li>底层配置好的连接池是：<strong>HikariDataSource</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Conditional(PooledDataSourceCondition.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">		DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,</span></span><br><span class="line"><span class="meta">		DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置</li>
<li>JdbcTemplateAutoConfiguration： <strong>JdbcTemplate的自动配置，可以来对数据库进行crud</strong><ul>
<li>可以修改这个配置项@ConfigurationProperties(prefix = <strong>“spring.jdbc”</strong>) 来修改JdbcTemplate</li>
<li>@Bean@Primary    JdbcTemplate；容器中有这个组件</li>
</ul>
</li>
<li>JndiDataSourceAutoConfiguration： jndi的自动配置</li>
<li>XADataSourceAutoConfiguration： 分布式事务相关的</li>
</ul>
</li>
</ul>
</li>
<li><p>配置文件中修改配置</p>
<ul>
<li>```yaml<br>spring:<br>  datasource:<pre><code>url: jdbc:mysql://localhost:3306/student
username: root
password: 1234567
driver-class-name: com.mysql.jdbc.Driver
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 测试数据库</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    @Slf4j</span><br><span class="line">    @SpringBootTest</span><br><span class="line">    class Boot04WebAdminApplicationTests &#123;</span><br><span class="line">    </span><br><span class="line">        @Autowired</span><br><span class="line">        JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">        @Test</span><br><span class="line">        void contextLoads() &#123;</span><br><span class="line">            </span><br><span class="line">    //        jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)</span><br><span class="line">    //        jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,)</span><br><span class="line">            Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from admin&quot;, Long.class);</span><br><span class="line">            log.info(&quot;记录总数：&#123;&#125;&quot;,aLong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-Druid数据源的使用"><a href="#2-Druid数据源的使用" class="headerlink" title="2. Druid数据源的使用"></a>2. Druid数据源的使用</h4><ul>
<li>druid官方github地址    <a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></li>
<li>使用Druid可以自定义使用，也可以starter</li>
</ul>
<ul>
<li><p>自定义方式</p>
<ul>
<li><p>先导入数据源依赖</p>
</li>
<li><p>```xml</p>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.6</version>
</dependency>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 编写配置类</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Configuration</span><br><span class="line">  public class MyDataSourceConfig &#123;</span><br><span class="line">  </span><br><span class="line">      // 默认的自动配置是判断容器中没有才会配@ConditionalOnMissingBean(DataSource.class)</span><br><span class="line">      //把我们数据源和配置文件spring.datasource里面的值进行绑定，不用再写用户名密码等信息</span><br><span class="line">      @ConfigurationProperties(&quot;spring.datasource&quot;)</span><br><span class="line">      @Bean</span><br><span class="line">      public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">          DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">  </span><br><span class="line">  //        druidDataSource.setUrl();</span><br><span class="line">  //        druidDataSource.setUsername();</span><br><span class="line">  //        druidDataSource.setPassword();</span><br><span class="line">          //加入监控功能</span><br><span class="line">          druidDataSource.setFilters(&quot;stat,wall&quot;);</span><br><span class="line">  </span><br><span class="line">  //        druidDataSource.setMaxActive(10);</span><br><span class="line">          return druidDataSource;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 配置 druid的监控页功能</span><br><span class="line">       * @return</span><br><span class="line">       */</span><br><span class="line">      @Bean</span><br><span class="line">      public ServletRegistrationBean statViewServlet()&#123;</span><br><span class="line">          StatViewServlet statViewServlet = new StatViewServlet();</span><br><span class="line">          ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(statViewServlet, &quot;/druid/*&quot;);</span><br><span class="line">  </span><br><span class="line">          registrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;);</span><br><span class="line">          registrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;123456&quot;);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          return registrationBean;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * WebStatFilter 用于采集web-jdbc关联监控的数据。</span><br><span class="line">       */</span><br><span class="line">      @Bean</span><br><span class="line">      public FilterRegistrationBean webStatFilter()&#123;</span><br><span class="line">          WebStatFilter webStatFilter = new WebStatFilter();</span><br><span class="line">  </span><br><span class="line">          FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(webStatFilter);</span><br><span class="line">          filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line">          filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);</span><br><span class="line">  </span><br><span class="line">          return filterRegistrationBean;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>官方starter方式（推荐）</p>
<ul>
<li><p>官方文档：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p>
</li>
<li><p>配置项列表： <a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p>
</li>
<li><p>先引入starter依赖</p>
</li>
<li><p>```xml</p>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.6</version>
</dependency>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 分析自动配置</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Configuration</span><br><span class="line">  @ConditionalOnClass(&#123;DruidDataSource.class&#125;)</span><br><span class="line">  @AutoConfigureBefore(&#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line">  @EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span><br><span class="line">  @Import(&#123;DruidSpringAopConfiguration.class, DruidStatViewServletConfiguration.class, DruidWebStatFilterConfiguration.class, DruidFilterConfiguration.class&#125;)</span><br><span class="line">  </span><br><span class="line">  1.可在配置文件中配置 spring.datasource.druid</span><br><span class="line">  2.</span><br><span class="line">      DruidSpringAopConfiguration.class,   监控SpringBean的；配置项：spring.datasource.druid.aop-patterns</span><br><span class="line">  	DruidStatViewServletConfiguration.class, 监控页的配置：spring.datasource.druid.stat-view-servlet；默认开启</span><br><span class="line">   	DruidWebStatFilterConfiguration.class, web监控配置；spring.datasource.druid.web-stat-filter；默认开启</span><br><span class="line">      DruidFilterConfiguration.class&#125;) 所有Druid自己filter的配置</span><br></pre></td></tr></table></figure></li>
<li><p>配置示例</p>
</li>
<li><p>```yaml<br>spring:<br>  datasource:</p>
<pre><code>url: jdbc:mysql://localhost:3306/student?characterEncoding=utf-8&amp;useSSL=false
username: root
password: 1234567
driver-class-name: com.mysql.jdbc.Driver

#druid配置
druid:
  aop-patterns: com.wjj.boot.*  #监控SpringBean
  filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

  stat-view-servlet: # 配置监控页功能
    enabled: true
    login-username: admin
    login-password: 123
    resetEnable: false

  web-stat-filter: # 监控web
    enabled: true
    urlPattern: /*
    exclusions: &#39;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#39;


  filter:
    stat: # 对上面filters里面的stat的详细配置
      slow-sql-millis: 1000
      logSlowSql: true
      enabled: true
    wall:
      enabled: true
      config:
        drop-table-allow: false
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3. 整合Mybatis</span><br><span class="line"></span><br><span class="line">- 官方GitHub地址: https://github.com/mybatis/spring-boot-starter/</span><br><span class="line"></span><br><span class="line">- starter命名</span><br><span class="line"></span><br><span class="line">  - SpringBoot官方的Starter：spring-boot-starter-*</span><br><span class="line">  - 第三方的： *-spring-boot-starter</span><br><span class="line"></span><br><span class="line">- 导入mybatis-starter </span><br><span class="line"></span><br><span class="line">  - 注意版本,每个版本都有对应版本要求</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.0&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p> 直接SPRING INITIALIZR上勾选</p>
</li>
</ul>
<ol>
<li><p><strong>配置模式</strong></p>
<ul>
<li><p>导入mybatis-starter </p>
</li>
<li><p>编写mapper接口。标注**@Mapper注解**</p>
<ul>
<li>```Java<br>@Mapper<br>public interface AccountMapper {<pre><code>Account queryById(int id);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 编写sql映射文件并绑定mapper接口</span><br><span class="line"></span><br><span class="line">  - ```xml</span><br><span class="line">    &lt;mapper namespace=&quot;com.wjj.boot.mapper.AccountMapper&quot;&gt;</span><br><span class="line">        &lt;select id=&quot;queryById&quot; resultType=&quot;com.wjj.boot.pojo.Account&quot;&gt;</span><br><span class="line">            select * from account where id = #&#123;id&#125;</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">    &lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 </p>
<ul>
<li>```yaml<br>mybatis:<h1 id="config-location-classpath-mybatis-mybatisConfig-xml"><a href="#config-location-classpath-mybatis-mybatisConfig-xml" class="headerlink" title="config-location: classpath:mybatis/mybatisConfig.xml"></a>config-location: classpath:mybatis/mybatisConfig.xml</h1>  mapper-locations: classpath:mybatis/mapper/*.xml<br>  configuration:<pre><code>map-underscore-to-camel-case: true    #数据库写法转驼峰写法
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 可以在application.yaml指定mybatis配置文件的位置,在mybatis-config.xml里面写配置</span><br><span class="line"></span><br><span class="line">  - 也可以直接在application.yaml里面写配置,不通过mybatis-config.xml</span><br><span class="line"></span><br><span class="line">  - 两者有冲突,推荐后者</span><br><span class="line"></span><br><span class="line">- 编写service,自动装配mapper接口</span><br><span class="line"></span><br><span class="line">  - 实际中应该写service接口，再写一个serviceImpl实现类，此处简化</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Service</span><br><span class="line">    public class AccountService &#123;</span><br><span class="line">        @Autowired</span><br><span class="line">        AccountMapper accountMapper;</span><br><span class="line">    </span><br><span class="line">        public Account queryById(int id)&#123;</span><br><span class="line">            return accountMapper.queryById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>controller代码测试</p>
<ul>
<li>```java<br>@Autowired<br>AccountService accountService;@ResponseBody<br>@GetMapping(“/query”)<br>public Account queryById(@RequestParam(“id”) int id){<pre><code>return accountService.queryById(id);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. 注解模式</span><br><span class="line"></span><br><span class="line">   - 在配置模式中不用额外编写sql映射文件,直接在mapper接口上写注解即可</span><br><span class="line"></span><br><span class="line">   - ```Java</span><br><span class="line">     @Mapper</span><br><span class="line">     public interface CityMapper &#123;</span><br><span class="line">     </span><br><span class="line">         @Select(&quot;select * from city where id=#&#123;id&#125;&quot;)</span><br><span class="line">         public City queryCityById(int id);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不适合复杂sql语句</li>
<li>增加耦合</li>
</ul>
</li>
</ul>
</li>
<li><p>混合模式</p>
<ul>
<li><p>实际上就是上面两种模式可以共存</p>
</li>
<li><p>SQL语句简单时可以使用注解,复杂时使用sql映射文件</p>
</li>
<li><p>```Java<br>@Mapper<br>public interface CityMapper {</p>
<pre><code>@Select(&quot;select * from city where id=#&#123;id&#125;&quot;)
public City queryCityById(int id);

public void insert(City city);
</code></pre>
<p>}</p>
<p>//sql映射文件<br>//useGeneratedKeys=”true” keyProperty=”id”    id自增<br>//@Options(useGeneratedKeys = true, keyProperty = “id”)注解方式的自增</p>
<mapper namespace="com.wjj.boot.mapper.CityMapper">
    <insert id="insert" useGeneratedKeys="true" keyProperty="id">
        insert into  city(`name`,`state`,`country`) values(#{name},#{state},#{country})
    </insert>
</mapper>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   - 最佳实战方式</span><br><span class="line">   </span><br><span class="line">     - 引入mybatis-starter</span><br><span class="line">     - **配置application.yaml中，指定mapper-location位置即可**</span><br><span class="line">   - 编写Mapper接口并标注@Mapper注解</span><br><span class="line">     - 简单方法直接注解方式</span><br><span class="line">     - 复杂方法编写mapper.xml进行绑定映射</span><br><span class="line">   - 在主程序上使用*@MapperScan(&quot;com.atguigu.admin.mapper&quot;) 简化，其他的接口就可以不用标注@Mapper注解*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 4. 整合Mybatis-Plus</span><br><span class="line"></span><br><span class="line">1. 官方介绍：https://mp.baomidou.com/guide</span><br><span class="line"></span><br><span class="line">   gitee源码地址：https://gitee.com/baomidou/mybatis-plus</span><br><span class="line"></span><br><span class="line">2. 快速实现</span><br><span class="line"></span><br><span class="line">   - 导入依赖</span><br><span class="line"></span><br><span class="line">     - ~~~xml</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;3.4.3.1&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       ~~~</span><br><span class="line"></span><br><span class="line">   - 编写配置类，默认已经配置好了不少</span><br><span class="line"></span><br><span class="line">     - 注：使用mybatis-plus之后，原先配置的mybatis会失效，需要重新在mybatis-plus配置</span><br><span class="line">     </span><br><span class="line">   - 编写实体类</span><br><span class="line">   </span><br><span class="line">     - ```Java</span><br><span class="line">       //该注解可以表明该字段不在数据库，否则mybatis-plus使用报错</span><br><span class="line">       @TableField(exist = false)</span><br><span class="line">       private String userName;</span><br><span class="line">       @TableField(exist = false)</span><br><span class="line">       private String password;</span><br><span class="line">       </span><br><span class="line">       //@TableName(&quot;user_tbl&quot;),默认根据类名获取数据库中的表名，当名字不一致，可以使用该注解指定数据库表</span><br><span class="line">       //@TableName(&quot;user_tbl&quot;)注解加在类前面</span><br></pre></td></tr></table></figure></li>
<li><p>编写mapper类</p>
<ul>
<li>```java<br>public interface UserMapper extends BaseMapper<User> {}//BaseMapper里面包括了基本的CRUD方法，我们不用额外再写<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 测试输出</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Autowired</span><br><span class="line">        private UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">        @Test</span><br><span class="line">        public void testSelect() &#123;</span><br><span class="line">            System.out.println((&quot;----- selectAll method test ------&quot;));</span><br><span class="line">            List&lt;User&gt; userList = userMapper.selectList(null);</span><br><span class="line">            Assert.assertEquals(5, userList.size());</span><br><span class="line">            userList.forEach(System.out::println);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>具体可参照官方文档</p>
</li>
</ul>
</li>
<li><p>CRUD功能的实现</p>
<ul>
<li><p>在上一部分的基础上进行</p>
</li>
<li><p>service层 Userservice 继承IService<User></p>
<ul>
<li>```java<br>public interface UserService extends IService<User> {<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实现service接口</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    @Service</span><br><span class="line">    public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>控制层实现数据的展示和数据删除</p>
<ul>
<li><p>RedirectAttributes重定向之后可以携带参数</p>
</li>
<li><p>```Java</p>
<pre><code>@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)
public String deleteUser(@PathVariable(&quot;id&quot;) Integer id,
                         @RequestParam(&quot;pn&quot;) Integer pn,
                         RedirectAttributes rn)&#123;

    userService.removeById(id);
    rn.addAttribute(pn);
    return &quot;redirect:/dynamic_table&quot;;
&#125;

@GetMapping(&quot;/dynamic_table&quot;)
public String dynamic_table(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn, Model model)&#123;
    
    List&lt;User&gt; list = userService.list();
</code></pre>
<p>//        model.addAttribute(“list”,list);</p>
<pre><code>    //分页查询数据
    Page&lt;User&gt; page = new Page&lt;&gt;(pn,2);

    //分页查询结果
    Page&lt;User&gt; userPage = userService.page(page, null);
    model.addAttribute(&quot;page&quot;,userPage);
    return &quot;data_tables/dynamic_table&quot;;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- html页面</span><br><span class="line"></span><br><span class="line">  - 传入page，page.records表示总分页数据</span><br><span class="line"></span><br><span class="line">  - 遍历加状态写法：th:each=&quot;user,status:$&#123;page.records&#125;&quot;，user表示每个遍历出来的用户，status表示状态</span><br><span class="line"></span><br><span class="line">  - 页面转发并携带参数写法：th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot; th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;</span><br><span class="line"></span><br><span class="line">  - 条件判断：th:if  th:switch</span><br><span class="line"></span><br><span class="line">  - 生成数字序列：#numbers.sequence(1,page.pages)，从一到末页</span><br><span class="line"></span><br><span class="line">  - ```html</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">                    &lt;th&gt;#&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;邮箱&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">    </span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,status:$&#123;page.records&#125;&quot;&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;Trident&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;Internet&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;Internet</span><br><span class="line">                            Explorer 4.0&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">                        &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;Win 95+&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;page.current&#125;)&#125;&quot; class=&quot;btn btn-danger btn-sm&quot; type=&quot;button&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">            &lt;!--分页条--&gt;</span><br><span class="line">                &lt;div class=&quot;row-fluid&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;span6&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;dataTables_info&quot; id=&quot;dynamic-table_info&quot;&gt;</span><br><span class="line">                            当前第[[$&#123;page.current&#125;]]页  总计 [[$&#123;page.pages&#125;]]页  共[[$&#123;page.total&#125;]]条记录</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;span6&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt;</span><br><span class="line">                            &lt;ul&gt;    </span><br><span class="line">                                &lt;!--判断是否有上一页--&gt;</span><br><span class="line">                                &lt;li th:switch=&quot;$&#123;page.hasPrevious()&#125;&quot;&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()-1&#125;)&#125;&quot; th:case=&quot;true&quot;&gt;← 前一页&lt;/a&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()&#125;)&#125;&quot; th:case=&quot;false&quot;&gt;← 前一页&lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                                &lt;li th:class=&quot;$&#123;num == page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;&quot; th:each=&quot;num:$&#123;#numbers.sequence(1,page.pages)&#125;&quot; &gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                                &lt;!--判断是否还有下一页--&gt;</span><br><span class="line">                                &lt;li th:switch=&quot;$&#123;page.hasNext()&#125;&quot;&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()+1&#125;)&#125;&quot; th:case=&quot;true&quot;&gt;下一页 → &lt;/a&gt;</span><br><span class="line">                                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;page.getCurrent()&#125;)&#125;&quot; th:case=&quot;false&quot;&gt;下一页 → &lt;/a&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-NOSQL"><a href="#3-2-NOSQL" class="headerlink" title="3.2 NOSQL"></a>3.2 NOSQL</h3><ul>
<li>NOSQL是指非关系型数据库</li>
<li>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</li>
</ul>
<h2 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4.单元测试"></a>4.单元测试</h2><h3 id="4-1-Junit5的基本介绍"><a href="#4-1-Junit5的基本介绍" class="headerlink" title="4.1. Junit5的基本介绍"></a>4.1. Junit5的基本介绍</h3><ul>
<li><p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</p>
</li>
<li><p>作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p>
<ul>
<li><strong>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></li>
<li><strong>JUnit Platform</strong>: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</li>
<li><strong>JUnit Jupiter</strong>: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个<strong>测试引擎</strong>，用于在Junit Platform上运行。</li>
<li><strong>JUnit Vintage</strong>: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。</li>
</ul>
</li>
<li><p>注意：</p>
<p><strong>SpringBoot 2.4 以上版本移除了默认对</strong> <strong>Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test****）</strong></p>
<p><strong>JUnit 5’s Vintage Engine Removed from</strong> <code>**spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage**</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>SpringBoot整合Junit5之后，项目创建就会自动生成一个测试类</p>
</li>
<li><p>编写新的测试只需要加上@Test注解（注意区分不同版本的@Test，需要Junit5的）</p>
</li>
<li><p>Junit类中包括Spring的功能，比如</p>
<ul>
<li>@Autowired 自动装配</li>
<li>@Transactional 标注测试方法，测试完成后自动回滚</li>
</ul>
</li>
<li><p>测试完成之后，可进行汇总报告，查看有多少断言异常，多少跳过</p>
<ul>
<li>断言一般都是产生异常错误</li>
<li>跳过包括前置条件和@Disabled </li>
</ul>
<p><img src="/SpringBoot-2-02.assets/image-20210727180518664.png" alt="image-20210727180518664"></p>
</li>
</ul>
<h3 id="4-2-Juint5常用注解"><a href="#4-2-Juint5常用注解" class="headerlink" title="4.2 Juint5常用注解"></a>4.2 Juint5常用注解</h3><ul>
<li>官方文档：<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</a></li>
</ul>
<ul>
<li><p>**@Test :**表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</p>
<ul>
<li>@Test测试执行的顺序跟方法名有关</li>
</ul>
</li>
<li><p>**@ParameterizedTest :**表示方法是参数化测试，下方会有详细介绍</p>
</li>
<li><p>**@RepeatedTest :**表示方法可重复执行，@RepeatedTest(5)</p>
</li>
<li><p>**@DisplayName :**为测试类或者测试方法设置展示名称</p>
</li>
<li><p><strong>@BeforeEach :<strong>表示在</strong>每个单元测试之前</strong>执行</p>
</li>
<li><p><strong>@AfterEach :<strong>表示在</strong>每个单元测试之后</strong>执行</p>
</li>
<li><p><strong>@BeforeAll :<strong>表示在</strong>所有</strong>单元测试之前执行，<strong>必须是static</strong></p>
</li>
<li><p><strong>@AfterAll :<strong>表示在</strong>所有</strong>单元测试之后执行，<strong>必须是static</strong></p>
</li>
<li><p>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</p>
</li>
<li><p>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</p>
</li>
<li><p>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</p>
</li>
<li><p>**@ExtendWith :**为测试类或测试方法提供扩展类引用</p>
<ul>
<li><p>@SpringBoot注解中就有</p>
</li>
<li><p>```java<br>/**</p>
<ul>
<li>@BootstrapWith(SpringBootTestContextBootstrapper.class)</li>
<li>@ExtendWith(SpringExtension.class)</li>
<li>/<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">import org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestDemo &#123;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  @DisplayName(&quot;第一次测试&quot;)</span><br><span class="line">  public void firstTest() &#123;</span><br><span class="line">      System.out.println(&quot;hello world&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 规定方法超时时间。超出时间测试出异常</span><br><span class="line">     *</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)</span><br><span class="line">    @Test</span><br><span class="line">    void testTimeout() throws InterruptedException &#123;</span><br><span class="line">        //只要超时就抛出异常</span><br><span class="line">        Thread.sleep(600);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    public void testBeforeEach()&#123;</span><br><span class="line">        System.out.println(&quot;每个测试前&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterEach</span><br><span class="line">    public void testAfterEach()&#123;</span><br><span class="line">        System.out.println(&quot;每个测试后&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @BeforeAll</span><br><span class="line">    static void testBeforeAll() &#123;</span><br><span class="line">        System.out.println(&quot;所有测试就要开始了...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterAll</span><br><span class="line">    static void testAfterAll() &#123;</span><br><span class="line">        System.out.println(&quot;所有测试以及结束了...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-断言机制"><a href="#4-3-断言机制" class="headerlink" title="4.3 断言机制"></a>4.3 断言机制</h3><p>官方文档：<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions">https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions</a></p>
<ul>
<li><p>*<em>这些断言方法都是 org.junit.jupiter.api.Assertions .<em>的静态方法</em></em></p>
</li>
<li></li>
</ul>
<h4 id="1-简单断言"><a href="#1-简单断言" class="headerlink" title="1. 简单断言"></a>1. 简单断言</h4><ul>
<li><p>对单个值进行简单的判断</p>
</li>
<li><p>当断言执行之后，测试不会继续往下走</p>
</li>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;simple assertion&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//前面的值时期盼值，后面的是实际值，最后面是自定义信息</span></span><br><span class="line">     assertEquals(<span class="number">3</span>, <span class="number">1</span> + <span class="number">2</span>, <span class="string">&quot;simple math&quot;</span>);</span><br><span class="line">     assertNotEquals(<span class="number">3</span>, <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     assertNotSame(<span class="keyword">new</span> Object(), <span class="keyword">new</span> Object());</span><br><span class="line">     Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">     assertSame(obj, obj);</span><br><span class="line"></span><br><span class="line">     assertFalse(<span class="number">1</span> &gt; <span class="number">2</span>);</span><br><span class="line">     assertTrue(<span class="number">1</span> &lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     assertNull(<span class="keyword">null</span>);</span><br><span class="line">     assertNotNull(<span class="keyword">new</span> Object());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-数组断言"><a href="#2-数组断言" class="headerlink" title="2. 数组断言"></a>2. 数组断言</h4><ul>
<li>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;array assertion&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> assertArrayEquals(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-组合断言"><a href="#3-组合断言" class="headerlink" title="3. 组合断言"></a>3. 组合断言</h4><ul>
<li><p>所有断言全部需要生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;assert all&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">              () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>),</span><br><span class="line">              () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">             );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-异常断言"><a href="#4-异常断言" class="headerlink" title="4. 异常断言"></a>4. 异常断言</h4><ul>
<li>JUnit5提供了一种新的断言方式<strong>Assertions.assertThrows()</strong> ,配合函数式编程就可以进行使用。</li>
<li>业务逻辑异常则不抛出异常，反之业务逻辑正常抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(</span><br><span class="line">           <span class="comment">//扔出断言异常</span></span><br><span class="line">            ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> % <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-超时断言"><a href="#5-超时断言" class="headerlink" title="5. 超时断言"></a>5. 超时断言</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Duration持续时间</span></span><br><span class="line">    assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-快速失败"><a href="#6-快速失败" class="headerlink" title="6. 快速失败"></a>6. 快速失败</h4><p>通过 fail 方法直接使得测试失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;fail&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> fail(<span class="string">&quot;This should fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-4-前置条件（assumptions）"><a href="#4-4-前置条件（assumptions）" class="headerlink" title="4.4 前置条件（assumptions）"></a>4.4 前置条件（assumptions）</h3><ul>
<li><p>前置条件和断言机制类似</p>
</li>
<li><p>不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;前置条件&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AssumptionsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assumeTrue(<span class="keyword">true</span>);</span><br><span class="line">    assumingThat(<span class="keyword">true</span>,() -&gt; System.out.println(<span class="string">&quot;成功&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
</li>
</ul>
<h3 id="4-5-嵌套测试"><a href="#4-5-嵌套测试" class="headerlink" title="4.5 嵌套测试"></a>4.5 嵌套测试</h3><ul>
<li><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试</p>
</li>
<li><p>嵌套外面的测试调用不了里面的@BeforeEach等，内层的可以调用外面的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestingAStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isInstantiatedWithNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">createNewStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AfterPushing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            String anElement = <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pushAnElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">isNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-6-参数化测试"><a href="#4-6-参数化测试" class="headerlink" title="4.6 参数化测试"></a>4.6 参数化测试</h3><p>官方文档：<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests</a></p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<p><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</p>
<p><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参</p>
<p><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参</p>
<p><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参</p>
<p><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;参数化测试&quot;)</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123; &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">palindromes</span><span class="params">(String candidate)</span> </span>&#123;</span><br><span class="line">    System.out.println(candidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-7-迁移注意"><a href="#4-7-迁移注意" class="headerlink" title="4.7 迁移注意"></a>4.7 迁移注意</h3><p>官方文档内容：</p>
<p>以下是在将现有 JUnit 4 测试迁移到 JUnit Jupiter 时应该注意的主题。</p>
<ul>
<li>Annotations 驻留在<code>org.junit.jupiter.api</code>包中。</li>
<li>Assertions 驻留在<code>org.junit.jupiter.api.Assertions</code>.<ul>
<li>请注意，您可以继续使用来自<code>org.junit.Assert</code>或任何其他断言库（例如<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>、<a href="https://hamcrest.org/JavaHamcrest/">Hamcrest</a>、<a href="https://truth.dev/">Truth</a>等）的断言方法。</li>
</ul>
</li>
<li>Assumptions 存在于<code>org.junit.jupiter.api.Assumptions</code>.<ul>
<li>请注意，JUnit Jupiter 5.4 和更高版本支持来自 JUnit 4 <code>org.junit.Assume</code>类的假设方法。具体来说，JUnit Jupiter 支持 JUnit 4<code>AssumptionViolatedException</code>发出信号，表明应该中止测试而不是将其标记为失败。</li>
</ul>
</li>
<li><code>@Before</code>和<code>@After</code>不再存在；使用<code>@BeforeEach</code>和<code>@AfterEach</code>代替。</li>
<li><code>@BeforeClass</code>和<code>@AfterClass</code>不再存在；使用<code>@BeforeAll</code>和<code>@AfterAll</code> 代替。</li>
<li><code>@Ignore</code>不再存在：使用<code>@Disabled</code>或其他内置一个 <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution">执行条件</a>，而不是<ul>
<li>另请参阅<a href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-ignore-annotation-support">JUnit 4 @Ignore 支持</a>。</li>
</ul>
</li>
<li><code>@Category</code>不复存在; 使用<code>@Tag</code>来代替。</li>
<li><code>@RunWith</code>不复存在; 由 <code>@ExtendWith</code>取代</li>
<li><code>@Rule</code>和<code>@ClassRule</code>不再存在；被<code>@ExtendWith</code>和 <code>@RegisterExtension</code>取代</li>
</ul>
<h2 id="5-指标监控"><a href="#5-指标监控" class="headerlink" title="5.指标监控"></a>5.指标监控</h2><h3 id="5-1-SpringBoot-Actuator"><a href="#5-1-SpringBoot-Actuator" class="headerlink" title="5.1 SpringBoot Actuator"></a>5.1 SpringBoot Actuator</h3><ol>
<li><p>简介</p>
<p>未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。</p>
<p>SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。</p>
</li>
<li><p>1.x 和 2.x 的不同</p>
<p><img src="/SpringBoot-2-02.assets/1606884394162-ac7f2d8e-7abb-44df-9998-fb0f2705f238.png" alt="image.png"></p>
</li>
</ol>
<ol start="3">
<li><p>简单使用</p>
<ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指标监控--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>访问 <a href="http://localhost:8080/actuator/">http://localhost:8080/actuator/</a></p>
<p>访问 <a href="http://localhost:8080/actuator/+%E5%85%B7%E4%BD%93%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8D%B3%E5%8F%AF">http://localhost:8080/actuator/+具体的端口即可</a></p>
<p><img src="/SpringBoot-2-02.assets/image-20210728123104731.png" alt="image-20210728123104731"></p>
</li>
<li><p>端点</p>
<ul>
<li><p>官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints">https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints</a></p>
</li>
<li><p>Actuator 端点可让您监控应用程序并与之交互。</p>
</li>
<li><p>Spring Boot 包含许多内置端点，并允许您添加自己的端点。例如，<code>health</code>端点提供基本的应用程序健康信息。</p>
</li>
<li><p>默认情况下，除<code>shutdown</code>之外的所有端点都是启动的</p>
</li>
<li><p>暴露端点，有JMX形式和web形式</p>
<ul>
<li><p>默认是否暴露，参见官方文档</p>
</li>
<li><p>JMX形式指</p>
<p><img src="/SpringBoot-2-02.assets/image-20210728154004054.png" alt="image-20210728154004054"></p>
</li>
<li><p>暴露所有形式为web</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span> <span class="comment">#启用所有端点信息</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span>  <span class="comment">#以web方式暴露</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="5-2-常用端口"><a href="#5-2-常用端口" class="headerlink" title="5.2 常用端口"></a>5.2 常用端口</h3><ol>
<li><p>Health Endpoint</p>
<ul>
<li><p>健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。</p>
</li>
<li><p>health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告</p>
</li>
<li><p>很多的健康检查默认已经自动配置好了，比如：数据库、redis等</p>
</li>
<li><p>可以很容易的添加自定义的健康检查机制</p>
</li>
<li><p>默认只有status可以自行打开</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="comment">#配置单个端点</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span> <span class="comment">#默认never</span></span><br></pre></td></tr></table></figure>

<p><img src="/SpringBoot-2-02.assets/image-20210728160953697.png" alt="image-20210728160953697"></p>
</li>
</ul>
</li>
<li><p>Metrics Endpoint</p>
<ul>
<li><p>提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；</p>
<ul>
<li><p>通过Metrics对接多种监控系统</p>
</li>
<li><p>简化核心Metrics开发</p>
</li>
<li><p>添加自定义Metrics或者扩展已有Metrics</p>
</li>
</ul>
</li>
<li><p>可以进一步访问，比如：<a href="http://localhost:8080/actuator/metrics/jvm.memory.max">http://localhost:8080/actuator/metrics/jvm.memory.max</a></p>
</li>
</ul>
<p><img src="/SpringBoot-2-02.assets/image-20210728161146945.png" alt="image-20210728161146945"></p>
</li>
</ol>
<h3 id="5-3-定制端口"><a href="#5-3-定制端口" class="headerlink" title="5.3 定制端口"></a>5.3 定制端口</h3><h4 id="1-定制Health信息"><a href="#1-定制Health信息" class="headerlink" title="1. 定制Health信息"></a>1. 定制Health信息</h4><ol>
<li><p>实现HealthIndicator接口</p>
</li>
<li><p>通过继承AbstractHealthIndicator类，最终命名为MyComHealthIndicator前缀MyCom</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComHealthIndicator</span> <span class="keyword">extends</span> <span class="title">AbstractHealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实的检查方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHealthCheck</span><span class="params">(Health.Builder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//mongodb。  获取连接进行测试</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 检查完成</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//            builder.up(); //健康</span></span><br><span class="line">            builder.status(Status.UP);</span><br><span class="line">            map.put(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            map.put(<span class="string">&quot;ms&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            builder.down();</span></span><br><span class="line">            builder.status(Status.OUT_OF_SERVICE);</span><br><span class="line">            map.put(<span class="string">&quot;err&quot;</span>,<span class="string">&quot;连接超时&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;ms&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        builder.withDetail(<span class="string">&quot;code&quot;</span>,<span class="number">100</span>)</span><br><span class="line">                .withDetails(map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/SpringBoot-2-02.assets/image-20210728165426782.png" alt="image-20210728165426782"></p>
</li>
</ol>
<h4 id="2-定制info信息"><a href="#2-定制info信息" class="headerlink" title="2. 定制info信息"></a>2. 定制info信息</h4><ol>
<li><p>编写配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">appName:</span> <span class="string">boot-admin</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">mavenProjectName:</span> <span class="string">@project.artifactId@</span>  <span class="comment">#使用@@可以获取maven的pom文件值</span></span><br><span class="line">  <span class="attr">mavenProjectVersion:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写InfoContributor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;example&quot;</span>,</span><br><span class="line">                Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/SpringBoot-2-02.assets/image-20210728170239632.png" alt="image-20210728170239632"></p>
</li>
</ol>
<h4 id="3-定制Metrics信息"><a href="#3-定制Metrics信息" class="headerlink" title="3. 定制Metrics信息"></a>3. 定制Metrics信息</h4><p>增加定制Metrics</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span>&#123;</span><br><span class="line">    Counter counter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(MeterRegistry meterRegistry)</span></span>&#123;</span><br><span class="line">         counter = meterRegistry.counter(<span class="string">&quot;myservice.method.running.counter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用下面的方式</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">MeterBinder <span class="title">queueSize</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">&quot;queueSize&quot;</span>, queue::size).register(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-定制端口"><a href="#4-定制端口" class="headerlink" title="4. 定制端口"></a>4. 定制端口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint(id = &quot;myService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getDockerInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//端点的读操作 http://localhost:8080/actuator/myService</span></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;docker started...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WriteOperation</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restartDocker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;docker restarted....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-4-实现可视化"><a href="#5-4-实现可视化" class="headerlink" title="5.4 实现可视化"></a>5.4 实现可视化</h3><p>官方GitHub：<a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p>
<p>快速开始：     <a href="https://codecentric.github.io/spring-boot-admin/2.3.1/#getting-started">https://codecentric.github.io/spring-boot-admin/2.3.1/#getting-started</a></p>
<ul>
<li><p>创建一个项目专门用来监控</p>
<ul>
<li><p>该项目导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>给主程序加上注解 @EnableAdminServer，同时设置不同的端口号方便区分</p>
</li>
</ul>
</li>
<li><p>给需要监控的项目配置</p>
<ul>
<li><p>```xml</p>
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-client</artifactId>
    <version>2.3.1</version>
</dependency>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 配置文件指向用于监控的项目，同时改变uri和应用名，保证监控在线</span><br><span class="line"></span><br><span class="line">  ```yaml</span><br><span class="line">  boot:</span><br><span class="line">    admin:</span><br><span class="line">      client:</span><br><span class="line">        url: http://localhost:8888/ #指向用于监控的端口</span><br><span class="line">        instance:</span><br><span class="line">          prefer-ip: true #改为使用server.address，默认hostname</span><br><span class="line">  application:</span><br><span class="line">    name: admin #改变应用名，默认名spring-boot-application</span><br></pre></td></tr></table></figure></li>
<li><p>注：程序的health必须是up，负责也会导致离线</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-原理解析"><a href="#6-原理解析" class="headerlink" title="6.原理解析"></a>6.原理解析</h2><h3 id="6-1-Profiles功能"><a href="#6-1-Profiles功能" class="headerlink" title="6.1 Profiles功能"></a>6.1 Profiles功能</h3><ul>
<li>该功能主要是为了便于存在不同生产环境时，可以方便快速的切换</li>
</ul>
<h4 id="1-application-profile功能"><a href="#1-application-profile功能" class="headerlink" title="1 . application-profile功能"></a>1 . application-profile功能</h4><ul>
<li><p>在配置文件中可以对生产环境进行切换，命名通常为application-xxx.yaml</p>
</li>
<li><p>```yaml<br>#指定激活的生产环境，两个配置文件都会生效，出现同名优先profiles<br>spring.profiles.active=test </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 默认的application.yaml默认都会生效</span><br><span class="line"></span><br><span class="line">- 激活指定环境</span><br><span class="line"></span><br><span class="line">  - 使用上述配置文件指定</span><br><span class="line">  - 使用命令行进行激活：</span><br><span class="line">    - java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha</span><br><span class="line">    - 同样可以在命令行中修改配置文件的指定值，**命令行优先级最高**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2. @Profile条件装配功能</span><br><span class="line"></span><br><span class="line">- 当有多个类都与配置进行绑定</span><br><span class="line"></span><br><span class="line">- 可使用@Profile(&quot;xxx&quot;)注解，不同类绑定不同的环境</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Profile(value = &#123;&quot;prod&quot;,&quot;default&quot;&#125;)</span><br><span class="line">  @Component</span><br><span class="line">  @ConfigurationProperties(&quot;person&quot;)</span><br><span class="line">  @Data</span><br><span class="line">  public class Boss implements Person &#123;</span><br><span class="line">  </span><br><span class="line">      private String name;</span><br><span class="line">      private Integer age;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-profile分组"><a href="#3-profile分组" class="headerlink" title="3. profile分组"></a>3. profile分组</h4><ul>
<li><p>可以通过分组同时加载多个环境</p>
</li>
<li><pre><code class="properties">spring.profiles.group.production[0]=proddb
spring.profiles.group.production[1]=prodmq

使用：--spring.profiles.active=production  激活
</code></pre>
</li>
</ul>
<h3 id="6-2-外部化配置"><a href="#6-2-外部化配置" class="headerlink" title="6.2 外部化配置"></a>6.2 外部化配置</h3><ul>
<li><p>官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config</a></p>
</li>
<li><p>可以在不同环境中使用相同的应用程序代码。可以使用各种外部配置源，包括 Java 属性文件、YAML 文件、环境变量和命令行参数。</p>
</li>
<li><p>Spring Boot 使用一个非常特殊的<code>PropertySource</code>顺序，旨在允许合理地覆盖值。属性按以下顺序考虑（较低项目的值覆盖较早的项目）：</p>
<ol>
<li>默认属性（由设置指定<code>SpringApplication.setDefaultProperties</code>）。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>你的<code>@Configuration</code>类的注释。请注意，<code>Environment</code>在刷新应用程序上下文之前，不会将此类属性源添加到。现在配置某些属性（例如在刷新开始之前读取的<code>logging.*</code>和）为时已晚<code>spring.main.*</code>。</li>
<li>配置数据（如<code>application.properties</code>文件）</li>
<li>一<code>RandomValuePropertySource</code>，只有在拥有性能<code>random.*</code>。</li>
<li>操作系统环境变量。</li>
<li>Java 系统属性 ( <code>System.getProperties()</code>)。</li>
<li>JNDI 属性来自<code>java:comp/env</code>.</li>
<li><code>ServletContext</code> 初始化参数。</li>
<li><code>ServletConfig</code> 初始化参数。</li>
<li>来自<code>SPRING_APPLICATION_JSON</code>（嵌入在环境变量或系统属性中的内联 JSON）的属性。</li>
<li>命令行参数。</li>
<li><code>properties</code>属性在您的测试中。可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests">用于测试应用程序的特定部分</a><a href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a>的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests">测试注释</a>。</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> 测试中的注释。</li>
<li><code>$HOME/.config/spring-boot</code>当 devtools 处于活动状态时，目录中的<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings">Devtools 全局设置属性</a>。</li>
</ol>
</li>
</ul>
<ol>
<li><p>配置数据文件可以从下面获取</p>
<p>(1) classpath 根路径</p>
<p>(2) classpath 根路径下config目录</p>
<p>(3) jar包当前目录</p>
<p>(4) jar包当前目录的config目录</p>
<p>(5) /config子目录的直接子目录</p>
<p>下面的配置会覆盖上面的</p>
</li>
<li><p>配置文件加载顺序</p>
<ol>
<li>当前jar包内部的application.properties和application.yml</li>
<li>当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li>
<li>引用的外部jar包的application.properties和application.yml</li>
<li>引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li>
</ol>
</li>
<li><p>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</p>
</li>
</ol>
<h3 id="6-3-自定义starter"><a href="#6-3-自定义starter" class="headerlink" title="6.3 自定义starter"></a>6.3 自定义starter</h3><ol>
<li><p>starter的原理</p>
<ul>
<li><p>starter的pom引入autoconfigurer </p>
</li>
<li><p>autoconfigure包中配置使用 <strong>META-INF/spring.factories</strong> 中 <strong>EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类</strong></p>
</li>
<li><p><strong>编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</strong></p>
<ul>
<li><strong>@Configuration</strong></li>
<li><strong>@Conditional</strong></li>
<li><strong>@EnableConfigurationProperties</strong></li>
<li><strong>@Bean</strong></li>
</ul>
</li>
<li><p>……</p>
</li>
</ul>
<p><strong>引入starter</strong> <strong>— xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —-</strong> <strong>配置项</strong></p>
</li>
<li><p>自定义starter</p>
<ol>
<li><p>创建一个atguigu-hello-spring-boot-starter（启动器）</p>
<p>再创建一个atguigu-hello-spring-boot-starter-autoconfigure（自动配置包）</p>
</li>
<li><p>启动器里面只需要导入自动配置包中的依赖</p>
</li>
<li><p>自动配置包里面写业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认不要放在容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix() + <span class="string">&quot;：&quot;</span> + userName + <span class="string">&quot;》&quot;</span> + helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个HelloProperties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;wjj.hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写HelloServiceAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span>  <span class="comment">//默认HelloProperties放在容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HelloService.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写<strong>spring.factories</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.wjj.hello.auto.HelloServiceAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>打包到本地仓库即可使用</p>
<ul>
<li>先打包自动配置包，再打包启动器</li>
<li>打包clean+install</li>
</ul>
</li>
<li><p>使用自定义starter</p>
<ul>
<li><p>导入相关starter依赖</p>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.helloProperties.getPrefix() + <span class="string">&quot;：&quot;</span> + userName + <span class="string">&quot;》&quot;</span> + <span class="keyword">this</span>.helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件可以写相关内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wjj.hello.prefix = 好好学习</span><br><span class="line">wjj.hello.suffix = 人</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="6-4-SpringBoot原理"><a href="#6-4-SpringBoot原理" class="headerlink" title="6.4 SpringBoot原理"></a>6.4 SpringBoot原理</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/article/8eda3648.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。常用的有Memcache，Redis,MongoDB</p>
<span id="more"></span>
<p><a name="MQgVJ"></a></p>
<h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><p><a name="ht0tJ"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。<br />NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。常用的有Memcache，Redis,MongoDB</p>
<ul>
<li><p> 不遵循SQL标准。</p>
</li>
<li><p>不支持ACID。</p>
</li>
<li><p>远超于SQL的性能。<br><a name="yNkn5"></a></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3></li>
<li><p>对数据高并发的读写</p>
</li>
<li><p>海量数据的读写</p>
</li>
<li><p>对数据高可扩展性的<br><a name="wNVQU"></a></p>
<h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3></li>
<li><p>需要事务支持</p>
</li>
<li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
</li>
<li><p>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</p>
</li>
</ul>
<p><a name="DpIxp"></a></p>
<h1 id="Redis概述安装"><a href="#Redis概述安装" class="headerlink" title="Redis概述安装"></a>Redis概述安装</h1><ol>
<li>安装步骤<ul>
<li>需要先安装gcc：<code>yum install gcc</code>（gcc –version命令判断有无安装）</li>
<li>到下载文件目录执行以下命令</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648457608820-18c1bbd4-02f5-47f9-a7df-c8a07674f174.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=u24c7864c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=263&originWidth=488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23326&status=done&style=none&taskId=u0dd6c0be-6f86-4bf1-bae2-1d5748dbe30&title=&width=376" alt="image.png"></li>
<li>make install安装结束</li>
</ul>
</li>
<li>安装默认文件目录及对应组件作用</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648457838490-dde71750-8965-4cfd-8b60-7e4dbea5f457.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u2f9d39c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22162&status=done&style=none&taskId=u3b0e7fc2-bc47-4d23-9a37-426e8321988&title=&width=488" alt="image.png"></p>
<ol start="3">
<li>启动redis服务<ol>
<li>前台启动（不推荐）</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648458313367-ec5fce37-858c-40ce-ac9a-e25064258a68.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=451&id=u9e95e2dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=780&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47917&status=done&style=none&taskId=u76ee5535-82f6-4502-981b-cb28b08bfed&title=&width=608" alt="image.png"><br />不推荐使用，离开这个页面就会自动关闭（CTRL+c手动关闭）</p>
<ol start="2">
<li>后台启动<ul>
<li>默认不支持后台启动，设置如下</li>
<li>复制redis.conf文件到其他目录 <code>cp redis.conf /etc/redis.conf</code></li>
<li>修改复制到新目录的redis.conf <code>vi redis.conf</code><strong>后台启动设置daemonize no改成yes</strong></li>
<li>重新回到usr/local/bin目录下启动 <code>redis-server /etc/redis.conf</code>    </li>
<li>客户端访问命令<code>redis-cli</code>(redis-cli -p6379）</li>
<li>查看redis相关端口<code>ps -ef|grep redis</code></li>
</ul>
</li>
<li>关闭服务<ol>
<li>单实例<code>redis-cli shutdown</code></li>
<li>多实例关闭，指定端口关闭：<code>redis-cli -p 6379 shutdown</code></li>
<li>进入终端直接shutdown</li>
<li>查看服务然后，kill pid</li>
</ol>
</li>
<li>相关知识</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648460933886-4bac4c71-021a-4f11-807b-9c22076f3a82.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=519&id=u14174963&margin=%5Bobject%20Object%5D&name=image.png&originHeight=626&originWidth=590&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100799&status=done&style=none&taskId=u49a7dfee-3b92-409b-acc7-84cfd10bbce&title=&width=489" alt="image.png"><br><a name="vURfD"></a></p>
<h1 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h1><p><a name="CkZty"></a></p>
<h2 id="key相关命令操作"><a href="#key相关命令操作" class="headerlink" title="key相关命令操作"></a>key相关命令操作</h2><ul>
<li>keys *查看当前库所有key    (匹配：keys *1)</li>
<li>exists key判断某个key是否存在</li>
<li>type key 查看你的key是什么类型</li>
<li>del key       删除指定的key数据</li>
<li>unlink key   根据value选择非阻塞删除</li>
<li>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li>
<li>expire key 10   10秒钟：为给定的key设置过期时间</li>
<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
</ul>
<p>其他命令</p>
<ul>
<li>select命令切换数据库</li>
<li>dbsize查看当前数据库的key的数量</li>
<li>flushdb清空当前库</li>
<li>flushall通杀全部库</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648461565022-a852c441-bdb2-4e1c-8f82-438618bd5d18.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=448&id=u6db9dc5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=448&originWidth=417&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23765&status=done&style=none&taskId=ucc34a6e4-a68a-4170-b34c-c811892a541&title=&width=417" alt="image.png"><br><a name="zq9K6"></a></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ol>
<li>String是Redis最基本的类型，一个key对应一个value。</li>
</ol>
<p>String类型是二进制安全的。Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。<br />String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>set   <key><value>添加键值对</li>
<li>get   <key>查询对应键值</li>
<li>append  <key><value>将给定的<value> 追加到原值的末尾</li>
<li>strlen  <key>获得值的长度</li>
<li>setnx  <key><value>只有在 key 不存在时    设置 key 的值</li>
<li>incr  <key></li>
<li>将key 中储存的数字值增1</li>
<li>只能对数字值操作，如果为空，新增值为1</li>
<li>decr  <key>将key 中储存的数字值减1；只能对数字值操作，如果为空，新增值为-1</li>
<li>incrby / decrby  <key>&lt;步长&gt;将key 中储存的数字值增减。自定义步长。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648462797876-dc1e1def-8833-4928-b841-e5822bc8ec2a.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=280&id=ue67c5cf6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=439&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16028&status=done&style=none&taskId=u7264a0fd-2c91-482a-979b-6b85c1dbe57&title=&width=439" alt="image.png"></li>
<li>mset  <key1><value1><key2><value2>  ….. 同时设置一个或多个key-value对  </li>
<li>mget  <key1><key2><key3> …..同时获取一个或多个value  </li>
<li>msetnx <key1><value1><key2><value2>  ….. 同时设置一个或多个key-value 对，当且仅当所有给定 key 都不存在。<strong>原子性，有一个失败则都失败</strong></li>
<li>getrange  <key>&lt;起始位置&gt;&lt;结束位置&gt;获得值的范围，类似java中的substring，<strong>前包，后包</strong></li>
<li>setrange  <key>&lt;起始位置&gt;<value>用<value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始**(索引从0开始)。**</li>
<li>setex  <key>&lt;过期时间&gt;<value>设置键值的同时，设置过期时间，单位秒。</li>
<li>getset <key><value>以新换旧，设置了新值同时获得旧值。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648519016984-6aa7e82f-fcea-4cce-a732-e3174005db5e.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=315&id=u60f4ea82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=581&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22294&status=done&style=none&taskId=ucd098e30-d34a-43bf-8980-1c2fba7e8c1&title=&width=512" alt="image.png"></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648462604994-d5022f3c-5a85-483f-8ec1-6a0cbf577081.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=26&id=u217af1d9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=26&originWidth=752&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3881&status=done&style=none&taskId=u93756029-f0ed-4fcc-adfa-7c27c0bcdc7&title=&width=752" alt="image.png"><br />set时候后面可选参数</p>
<ul>
<li>*NX：当数据库中key不存在时，可以将key-value添加数据库</li>
<li>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</li>
<li>*EX：key的超时秒数</li>
<li>*PX：key的超时毫秒数，与EX互斥</li>
</ul>
<p>注意：redis中的操作均是<strong>原子操作</strong>，因为redis本身就是<strong>单线程</strong>的；Java中不是原子操作<br />有意思的示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648462953427-15f21bde-e77a-402d-afa4-55536f96b0ec.png#clientId=udc7b9c96-2f46-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=ub53e2754&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88858&status=done&style=none&taskId=ue6ad133f-d99d-4d6d-a65f-c5082fdaa46&title=&width=677" alt="image.png"></p>
<ol start="3">
<li>数据结构</li>
</ol>
<p>类似于Java中的arraylist;<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648519095030-25da5e72-5d5f-4097-a17a-f6bcf207eae8.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=100&id=ub25ebb18&margin=%5Bobject%20Object%5D&name=image.png&originHeight=101&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=224360&status=done&style=none&taskId=u7107cda3-361a-420e-a51f-c30d31d7f41&title=&width=547" alt="image.png"><br />如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<p><a name="OyFTP"></a></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ol>
<li>简介</li>
</ol>
<p>单键多值，底层为一个双向列表，可从两端插入数据，根据插入数据排序。</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>lpush/rpush  <key><value1><value2><value3> …. 从左边/右边插入一个或多个值。</li>
<li>lpop/rpop  <key>从左边/右边吐出一个值。<strong>值在键在，值光键亡。</strong></li>
<li>rpoplpush  <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</li>
</ul>
<p><strong>改成lpoprpush不行</strong></p>
<ul>
<li>lrange <key><start><stop>按照索引下标获得元素(从左到右)（<strong>0-1表示获取所有</strong>）</li>
<li>lindex <key><index>按照索引下标获得元素(从左到右)</li>
<li>llen <key>获得列表长度 </li>
<li>linsert <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值</li>
<li>lrem <key><n><value>从左边删除n个value(从左到右)</li>
<li>lset<key><index><value>将列表key下标为index的值替换成value</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648520560469-71519f30-9888-43ce-b33c-79b32cd0e58d.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=487&id=u868c4ca9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=645&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28149&status=done&style=none&taskId=u402dd7d3-1240-4e9c-800e-6145c85b3d4&title=&width=645" alt="image.png"></li>
</ul>
<ol start="3">
<li>数据结构</li>
</ol>
<p>List的数据结构为<strong>快速链表quickList</strong>。<br />首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br />它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br />当数据量比较多的时候才会改成quicklist。<br />因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648520493068-6b6cea1c-99a3-47fd-b8eb-7c2e174c213f.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=58&id=u1832bc9d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=58&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128870&status=done&style=none&taskId=u8a81997c-9f45-4a88-bba2-7faf22bbe4b&title=&width=554" alt="image.png"><br /><strong>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。<br><a name="dnT1x"></a></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ol>
<li>简介</li>
</ol>
<p>可以看作没有重复值的list；并且set提供判断一个值是否存在于key中</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>sadd <key><value1><value2> ….. 将一个或多个member 元素加入到集合 key 中，已经存在的member 元素将被忽略</li>
<li>smembers <key>查看该集合的所有值。</li>
<li>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</li>
<li>scard<key>返回该集合的元素个数。</li>
<li>srem <key><value1><value2> …. 删除集合中的指定元素。</li>
<li>spop <key>随机从该集合中吐出一个值，<strong>并将其删除</strong>。</li>
<li>srandmember <key><n>随机从该集合中取出n个值。<strong>不会从集合中删除</strong> 。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648521184199-6574cb3b-3719-45ed-b9b9-972286234029.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=uc5a21500&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16615&status=done&style=none&taskId=u4be85c96-9b90-4bfe-85c7-f8e3df187d4&title=&width=490" alt="image.png">     </li>
<li>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</li>
<li>sinter <key1><key2>返回两个集合的交集元素。</li>
<li>sunion <key1><key2>返回两个集合的并集元素。</li>
<li>sdiff <key1><key2>返回两个集合的差集元素(key1中的，不包含key2中的)</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648521513089-22a918f0-40d3-45b9-8c94-f0b138c3115d.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=389&id=u40258b4c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=389&originWidth=457&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18790&status=done&style=none&taskId=u1350487a-4bf8-4d04-82d1-88d178410d3&title=&width=457" alt="image.png"></li>
</ul>
<ol start="3">
<li>数据结构</li>
</ol>
<p>Set数据结构是dict字典，字典是用<strong>哈希表实现的</strong>。<br />Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<p><a name="h3aln"></a></p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ol>
<li>简介</li>
</ol>
<p>hash就相当于键值对的集合，适合存储对象，key为字符串，value为键值对集合；类似于Java中的map，如下图所示<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648521751048-395f2150-3bf0-4183-9517-e1ae69f1bfc2.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=391&id=uf9334da6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=731&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18238&status=done&style=none&taskId=u7e4803b7-e396-40a7-b4a8-7c430431f8f&title=&width=731" alt="image.png"></p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>hset <key><field><value>给<key>集合中的  <field>键赋值<value></li>
<li>hget <key1><field>从<key1>集合<field>取出value </li>
<li>hmset <key1><field1><value1><field2><value2>… <strong>批量设置hash的值</strong></li>
<li>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在。</li>
<li>hkeys <key>列出该hash集合的所有field</li>
<li>hvals <key>列出该hash集合的所有value</li>
<li>hincrby <key><field><increment>为哈希表 key 中的域 field 的值加上增量1   -1</li>
<li>hsetnx <key><field><value>将哈希表 key 中的域 field 的值设置为value ，<strong>当且仅当域field 不存在.</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648522491076-55012086-0f9f-425a-b8fa-d98b87bfa203.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=402&id=ue96de86c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21949&status=done&style=none&taskId=u1b7eb7ad-16ba-44a6-8e02-4743770dc59&title=&width=524" alt="image.png"></li>
</ul>
<ol start="3">
<li>数据结构</li>
</ol>
<p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。<br><a name="f6SyH"></a></p>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><ol>
<li>简介</li>
</ol>
<p>zset就是一个有序的set，实现可以理解为hash，不过添加了一个score，来根据这个score的大小进行排序。</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>zadd  <key><score1><value1><score2><value2>…将一个或多个member 元素及其 score 值加入到有序集key 当中。</li>
<li>zrange <key><start><stop>  [WITHSCORES]   返回有序集key 中，下标在<start><stop>之间的元素（0，-1全部返回）带WITHSCORES，可以让分数一起和值返回到结果集。</li>
<li>zrangebyscore key [withscores] [limit offset count]返回有序集key 中，所有 score 值介于min 和max 之间(包括等于min 或max )的成员。有序集成员按score 值递增**(从小到大**)次序排列。</li>
<li>z<strong>rev</strong>rangebyscore key [withscores] [limit offset count]  同上，改为<strong>从大到小</strong>排列。</li>
<li>zincrby <key><increment><value>      为元素的score加上增量</li>
<li>zrem  <key><value>删除该集合下，指定值的元素 </li>
<li>zcount <key><min><max>统计该集合，分数区间内的元素个数 </li>
<li>zrank <key><value>返回该值在集合中的排名，从0开始。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648523954231-3aa0ff19-119a-410d-94b6-0e2b464d97b4.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=378&id=ucbe1ea33&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22850&status=done&style=none&taskId=ua3eab6bc-3bbe-4254-9ae6-0ed12502159&title=&width=508" alt="image.png"></li>
</ul>
<ol start="3">
<li>数据结构</li>
</ol>
<p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构        Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br />zset底层使用了两个数据结构<br />（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br />（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<p><a name="so8Mb"></a></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ol>
<li>网络相关配置</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648525104515-bf65f784-c7fd-43e2-8d89-e26e23f0b529.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=84&id=u1b86e37f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4656&status=done&style=none&taskId=ue30df820-8c8f-4841-9c60-be3b8973ecb&title=&width=572" alt="image.png"><br />默认只接受本机访问，不写则不限则；<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648525227289-af69111d-22dc-4d05-b5d8-25f218c2283f.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=150&id=u2aa619f9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=530&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9741&status=done&style=none&taskId=u0826ebb8-4321-4630-a2cf-0cefa923596&title=&width=530" alt="image.png"><br />生产环境要写应用服务器的地址；服务器是需要远程访问的，所以需要将<strong>bind</strong>注释掉，并且<strong>protected-mode no</strong>(本机保护模式，这个代表只接受本机访问）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648525672469-7894164b-3076-4c18-856e-16149b42c549.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=558&id=ua3956d60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=558&originWidth=587&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39188&status=done&style=none&taskId=u6dc29112-0043-49e4-bb0b-4b2cd46a2ce&title=&width=587" alt="image.png">\</p>
<ul>
<li>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列+ 已经完成三次握手队列。</li>
<li>timeout 一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</li>
<li>tcp keepalive对访问客户端的一种心跳检测，每个n秒检测一次。单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </li>
</ul>
<ol start="2">
<li>通用设置</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648533519923-f3650330-4041-4b03-993a-acdb4b1b05e2.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=72&id=ub191bc65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5926&status=done&style=none&taskId=ud2cf7b86-a2a7-4073-833a-6f18210fd4d&title=&width=564" alt="image.png"><br />后台启动<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648533564056-aa77bd14-1ff5-4d9a-af01-ab6540a7afca.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=63&id=u7a033f99&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4045&status=done&style=none&taskId=u50977b44-123d-4e38-88d4-467f236772c&title=&width=549" alt="image.png"><br />存放pid文件的位置·，每个实例不同pid文件<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648533610290-03ef0f35-23e0-4da1-a85f-6f35c7759c73.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=115&id=u5c2eb13c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=520&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7407&status=done&style=none&taskId=ue727aff0-488e-4d25-bf4a-bdf6fd975d7&title=&width=520" alt="image.png"><br />日志级别设置：指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice；</strong>四个级别根据使用阶段来选择，生产环境选择notice 或者warning<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648533664184-252a8541-e27d-4af5-bc0a-aac12b0e3105.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=79&id=u234d9a6e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=79&originWidth=514&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4773&status=done&style=none&taskId=ud2bf6ec9-f2e0-47ad-b81b-0a3cb7d61d8&title=&width=514" alt="image.png"><br />日志文件存放位置<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648533689626-1c6008ad-a50a-49fc-b1e2-3ed2895c251b.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=uaa808f83&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=563&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5705&status=done&style=none&taskId=ud5cfa69f-7c43-43dd-8fd8-f62065fae4c&title=&width=563" alt="image.png"><br />数据库数目，默认16个</p>
<ol start="3">
<li>密码设置</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648534120632-c56be186-670b-40a3-9279-8c358546eded.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=90&id=u9843dceb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=90&originWidth=577&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5377&status=done&style=none&taskId=u2709a830-bb8d-4a08-b2bc-8b5b18b24c2&title=&width=577" alt="image.png"><br />设置密码<br />在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。<br />永久设置，需要再配置文件中进行设置。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648534193361-d1172d97-cf99-4cce-99c1-c758988ea273.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=uc9851904&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=556&originalType=binary&ratio=1&rotation=0&showTitle=false&size=766715&status=done&style=none&taskId=u94269cc6-53b7-4953-93a7-50eaecdf2b0&title=&width=556" alt="image.png"></p>
<p><a name="V7LQN"></a></p>
<h1 id="Redis中的发布和订阅"><a href="#Redis中的发布和订阅" class="headerlink" title="Redis中的发布和订阅"></a>Redis中的发布和订阅</h1><ol>
<li>概念</li>
</ol>
<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br />Redis 客户端可以订阅任意数量的频道。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648534545419-5c32c590-61fd-478b-850e-5d11ce0f70c3.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=203&id=u0fa06698&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=315&originalType=binary&ratio=1&rotation=0&showTitle=false&size=256479&status=done&style=none&taskId=u77a96c95-6013-4907-9bb2-7bf06d1a0bb&title=&width=315" alt="image.png"></p>
<ol start="2">
<li>命令实现</li>
</ol>
<ul>
<li>打开一个客户端订阅channel1  <code>SUBSCRIBE channel1</code></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648534670935-7e78dade-1bca-4a3f-8354-d5840d047f8a.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=86&id=u659f58e6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=86&originWidth=300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103534&status=done&style=none&taskId=uf0ea182f-a581-4bb7-b103-6e6b989092b&title=&width=300" alt="image.png"></p>
<ul>
<li>打开另一个客户端，给channel1发布消息hello <code>publish channel1 hello</code></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648534693116-aaf579b2-52a1-4875-b10d-54bbf18f770e.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=33&id=u59326715&margin=%5Bobject%20Object%5D&name=image.png&originHeight=33&originWidth=318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42163&status=done&style=none&taskId=u42f25462-4328-4bf8-b8ec-8b9a2775bb0&title=&width=318" alt="image.png"><br />返回的1是订阅者数量</p>
<ul>
<li>打开第一个客户端可以看到发送的消息</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648534715847-db018f58-a03e-4d16-bf3e-d67280dffb37.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=131&id=u3eff0373&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=319&originalType=binary&ratio=1&rotation=0&showTitle=false&size=167641&status=done&style=none&taskId=u93bec09f-9ad3-46cc-95fa-76d6247d0d3&title=&width=319" alt="image.png"><br />注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息<br><a name="tPtGW"></a></p>
<h1 id="新的数据类型"><a href="#新的数据类型" class="headerlink" title="新的数据类型"></a>新的数据类型</h1><p><a name="pizas"></a></p>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><ol>
<li>简介</li>
</ol>
<p>本质上就是字符串，不过是在位上操作；大量用户访问可以减少内存占用</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）*offset:偏移量从0开始</li>
<li>getbit<key><offset>获取Bitmaps中某个偏移量的值</li>
<li>bitcount<key>[start end] 统计字符串从start<strong>字节</strong>到end<strong>字节</strong>比特值为1的数量，统计<strong>字符串</strong>被设置为1的bit数</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648536090968-8df066a1-c171-4531-b823-431b4595a59a.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=303&id=u294dad02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=649&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26899&status=done&style=none&taskId=u35ea2621-78f3-40e8-9a33-cc26ef0c939&title=&width=649" alt="image.png"></li>
<li>bitop  and(or/not/xor) <destkey> [key…]  bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在<strong>destkey</strong>中。</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648536716794-e38f1ddf-675f-452f-b0b6-707c9d55965e.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=84&id=ubf46cc7a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5456&status=done&style=none&taskId=ufa77552f-4346-4c67-af5a-c22860523e1&title=&width=425" alt="image.png"><br><a name="jOquS"></a><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><strong>HyperLogLog</strong></h2></li>
</ul>
<ol>
<li>简介</li>
</ol>
<p>主要适用于解决基数问题（可以粗略理解为大量数据的去重，用很小的精度来解决大量的去重）</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>pfadd <key>&lt; element&gt; [element …]   添加指定元素到HyperLogLog 中</li>
<li>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</li>
<li>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648537539346-6ad924d4-2907-4fa9-aa83-55a2bd8a0ef1.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=175&id=uacdacb24&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=501&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10923&status=done&style=none&taskId=u8a5bbf9d-3d05-467b-bba1-b1960b8334f&title=&width=501" alt="image.png"><br><a name="js5lI"></a><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a><strong>Geospatial</strong></h2></li>
</ul>
<ol>
<li>简介</li>
</ol>
<p>主要是对地理信息相关的操作</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]   添加地理位置（经度，纬度，名称）</li>
<li>geopos  <key><member> [member…]  获得指定地区的坐标值</li>
<li>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离</li>
<li>georadius<key>&lt; longitude&gt;<latitude>radius  m|km|ft|mi   以给定的经纬度为中心，找出某一半径内的元素</li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648538207831-abceda4f-1ec4-4d09-b401-bc9d5084f70e.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=uf546d35a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=823&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25417&status=done&style=none&taskId=ue42b371d-4c16-45f6-82e9-812c87d4291&title=&width=823" alt="image.png"></li>
</ul>
<p><a name="Dr3SP"></a></p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><ol>
<li>简介</li>
</ol>
<p>主要用于Java中操作redis</p>
<ol start="2">
<li><p>使用准备</p>
<ol>
<li><p>导入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>linux系统中修改配置文件，关闭防火墙</p>
</li>
</ol>
</li>
</ol>
<p>systemctl status firewalld（查看防火墙状态）<br />**systemctl stop/disable firewalld.service   **<br />redis.conf中注释掉bind 127.0.0.1 ,然后protected-mode no</p>
<ol start="3">
<li><p>测试连接成功与否</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.241.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功则结果为 pong</span></span><br></pre></td></tr></table></figure></li>
<li><p>操作</p>
</li>
</ol>
<p>操作与命令方式一样，就相当于用<strong>jedis操作这个命令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.241.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line"></span><br><span class="line">    jedis.mset(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;v3&quot;</span>); <span class="comment">//添加string</span></span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">    System.out.println(jedis.keys(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">    System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>验证码实例</p>
<ol>
<li>实现思路<img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648541004127-05be695c-7ac0-4d1c-9e64-05d7e9321098.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=215&id=uc349d3d5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=1122&originalType=binary&ratio=1&rotation=0&showTitle=false&size=217093&status=done&style=none&taskId=u43e32814-1d7b-4c7f-9702-43a9b291909&title=&width=674" alt="image.png"></li>
<li>代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">verifyCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(getCode());</span></span><br><span class="line">        codeRedis(<span class="string">&quot;11212121234&quot;</span>,getCode());</span><br><span class="line"><span class="comment">//        getResult(&quot;11212121234&quot;,&quot;967191&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 生成随机验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String code=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            code+=random.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 redis存入数据，并设置过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">codeRedis</span><span class="params">(String phone,String code)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.241.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        String countKey=<span class="string">&quot;code&quot;</span>+phone+<span class="string">&quot;count:&quot;</span>;</span><br><span class="line">        String codeKey=<span class="string">&quot;code&quot;</span>+phone+<span class="string">&quot;:&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断次数，并存入redis</span></span><br><span class="line">        String count=jedis.get(countKey);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;</span><br><span class="line">            jedis.setex(countKey,<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count)&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            jedis.incr(countKey);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已达上限三次&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将对应验证码加入redis</span></span><br><span class="line">        jedis.setex(codeKey,<span class="number">120</span>,code);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">(String phone,String code)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.241.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        String codeKey=<span class="string">&quot;code&quot;</span>+phone+<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(code.equals(jedis.get(codeKey)))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a name="euBi1"></a><h1 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h1></li>
</ol>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.241.128</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制层编写</p>
</li>
</ol>
<p>主要对redis的操作使用<strong>RedisTemplate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="JkkVe"></a></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ol>
<li>简介</li>
</ol>
<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br />Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<ol start="2">
<li>命令</li>
</ol>
<ul>
<li>multi 组队</li>
<li>exec执行</li>
<li>discard 中断组队        <img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648546629755-d91a5b55-f8a3-4d73-8b65-f448aa7a7b7d.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=260&id=udb274999&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16409&status=done&style=none&taskId=ua455d4ee-4a52-4674-9a77-ec5bd7cde0d&title=&width=691" alt="image.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648546989606-9ec192e9-e2ec-4cec-8bac-d41cb4226e6f.png#clientId=u6b2c068c-dfad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=u8e991773&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=552&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23403&status=done&style=none&taskId=ud540e6d0-7423-41f0-9fee-e5b15baf39d&title=&width=552" alt="image.png"></li>
</ul>
<ol start="3">
<li>疑问：为什么redis是单线程的还需要事务呢？</li>
</ol>
<p>对于redis服务器本身而言是没有竞态的，将活跃的客户端一个一个取出，将客户端中的请求一条一条执行，所有的处理都是one by one的。<br />但是，对于客户端而言是存在静态的，<strong>一个redis服务器会有多个客户端进行连接</strong>，他们之间可能会出现竞态的。</p>
<ol start="4">
<li>redis解决事务冲突的方法</li>
</ol>
<p>乐观锁。<strong>乐观锁(Optimistic Lock), <strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<ul>
<li>乐观锁执行命令：watch key1 [key2]</li>
</ul>
<p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong></p>
<ul>
<li>**unwatch **取消WATCH 命令对所有key 的监视。</li>
</ul>
<p>如果在执行WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<ol start="5">
<li>redis事务的特性</li>
</ol>
<ul>
<li>单独隔离操作<ul>
<li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
</ul>
</li>
<li>无隔离级别概念<ul>
<li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li>
</ul>
</li>
<li>不保证原子性<ul>
<li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </li>
</ul>
</li>
</ul>
<ol start="6">
<li>事务–秒杀实例<ol>
<li>使用工具ab，来模拟秒杀请求的发送，多个请求以及并发</li>
</ol>
</li>
</ol>
<p>安装方式：yum install httpd-tools<br />使用命令：<code>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded http://192.168.2.115:8081/Seckill/doseckill</code>（模拟2000个用户，200个并发）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648793686758-74a9dc77-ed8a-48c3-9d4f-b2a6ba186762.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=443&id=u972e4102&margin=%5Bobject%20Object%5D&name=image.png&originHeight=659&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62499&status=done&style=none&taskId=u6a14dd72-4920-4a4b-ba62-cbb6c9f7a74&title=&width=576" alt="image.png"></p>
<ol start="2">
<li>出现连接超时的问题</li>
</ol>
<p>使用连接池来解决,节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">					JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">					poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">					poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">					poolConfig.setMaxWaitMillis(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">					poolConfig.setBlockWhenExhausted(<span class="keyword">true</span>);</span><br><span class="line">					poolConfig.setTestOnBorrow(<span class="keyword">true</span>);  <span class="comment">// ping  PONG</span></span><br><span class="line">				 </span><br><span class="line">					jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;192.168.44.168&quot;</span>, <span class="number">6379</span>, <span class="number">60000</span> );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> jedisPool;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">			jedisPool.returnResource(jedis);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>出现超卖问题，产品库存出现负数</li>
</ol>
<p>解决，使用乐观锁来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//秒杀过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid,String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 uid和prodid非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(uid == <span class="keyword">null</span> || prodid == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 连接redis</span></span><br><span class="line">    <span class="comment">//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span></span><br><span class="line">    <span class="comment">//通过连接池得到jedis对象</span></span><br><span class="line">    JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">    Jedis jedis = jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 拼接key</span></span><br><span class="line">    <span class="comment">// 3.1 库存key</span></span><br><span class="line">    String kcKey = <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">    <span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line">    String userKey = <span class="string">&quot;sk:&quot;</span>+prodid+<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监视库存</span></span><br><span class="line">    jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4 获取库存，如果库存null，秒杀还没有开始</span></span><br><span class="line">    String kc = jedis.get(kcKey);</span><br><span class="line">    <span class="keyword">if</span>(kc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;秒杀还没有开始，请等待&quot;</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 判断用户是否重复秒杀操作</span></span><br><span class="line">    <span class="keyword">if</span>(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀&quot;</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6 判断如果商品数量，库存数量小于1，秒杀结束</span></span><br><span class="line">    <span class="keyword">if</span>(Integer.parseInt(kc)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7 秒杀过程</span></span><br><span class="line">    <span class="comment">//使用事务</span></span><br><span class="line">    Transaction multi = jedis.multi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组队操作</span></span><br><span class="line">    multi.decr(kcKey);</span><br><span class="line">    multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(results == <span class="keyword">null</span> || results.size()==<span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;秒杀失败了....&quot;</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.1 库存-1</span></span><br><span class="line">    <span class="comment">//jedis.decr(kcKey);</span></span><br><span class="line">    <span class="comment">//7.2 把秒杀成功用户添加清单里面</span></span><br><span class="line">    <span class="comment">//jedis.sadd(userKey,uid);</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;秒杀成功了..&quot;</span>);</span><br><span class="line">    jedis.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>库存遗留问题</li>
</ol>
<p>指抢购结束，有人没抢到商品，库存却还有。原因：乐观锁导致很多请求失败了，先点的失败，后点却成功了。通过LUA脚本来解决这个问题：<br />将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。LUA脚本是类似redis事务，<strong>有一定的原子性，不会被其他命令插队</strong>，可以完成一些redis事务性的操作。但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。<br />利用lua脚本淘汰用户，解决超卖问题。<br />redis 2.6版本以后，<strong>通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</strong><br><a name="Onriq"></a></p>
<h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><p>redis信息存在内存之中，持久化就是将其存到硬盘之中<br><a name="GSwuU"></a></p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ol>
<li>简介</li>
</ol>
<p>redis database，在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。<strong>redis默认开启</strong></p>
<ol start="2">
<li>执行过程</li>
</ol>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648803770803-6b644b92-5901-452f-9e04-d79f34285aa8.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=196&id=u0e3445ab&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=533&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32136&status=done&style=none&taskId=u22c96676-9f5a-4587-97a1-a19d242df54&title=&width=533" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648803787926-607872d4-604d-4c97-97d3-7a447cf31faf.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=257&id=ubcb01135&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=369&originalType=binary&ratio=1&rotation=0&showTitle=false&size=380285&status=done&style=none&taskId=u23aafdde-2e05-4458-aa1c-aebe602796c&title=&width=369" alt="image.png"><br />为什么要用临时文件，而不是直接持久化到硬盘之中呢？<br />防止持久化的数据缺失，不完整；比如，我数据复制到一半的时候，服务器挂了，那硬盘之中的数据就是异常的，显然不行。复制到临时文件中就不用考虑，因为是否备份的权力还是在我自己。</p>
<ol start="3">
<li>配置文件中相关的信息</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648804027310-9c92d91e-ac83-4419-9231-7feaafeb43c1.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=98&id=uda0af975&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=464&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7209&status=done&style=none&taskId=u95e5de3e-a074-44cf-aa6b-29233f09578&title=&width=464" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648804129394-95f64cdf-ae2a-4b2e-bb8d-31859916f88c.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=60&id=u133be509&margin=%5Bobject%20Object%5D&name=image.png&originHeight=60&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5873&status=done&style=none&taskId=ubde03a96-fbad-461b-96df-023984ca17f&title=&width=497" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648804247337-11d14558-ce0d-48be-8f3b-45827744a55a.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=83&id=u89da5b15&margin=%5Bobject%20Object%5D&name=image.png&originHeight=83&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7885&status=done&style=none&taskId=ue7f03418-c70a-48a3-87be-a75b55b1065&title=&width=396" alt="image.png"></p>
<ol start="4">
<li>测试备份使用方法</li>
</ol>
<p>先关闭redis，复制dump.rdb到其他地方，即使删除原来的dump.rdb，将复制的文件复制回来，redis依然可以在重启的时候加载出数据。<br />停止保存策略：<code>redis-cli config set save &quot;&quot;</code>#save后给空值，表示禁用保存策略</p>
<p><a name="PzuHZ"></a></p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ol>
<li>简介</li>
</ol>
<p>append only file，以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。<strong>redis默认关闭</strong></p>
<ol start="2">
<li>执行流程<ol>
<li>客户端的请求写命令会被append追加到AOF缓冲区内；</li>
<li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；<ul>
<li>压缩是指将某些产生相同结果的命令缩减，比如多个set，压缩成mset。可以使用命令bgrewriteaof</li>
<li>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</li>
<li>触发时刻：Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</li>
<li>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 </li>
</ul>
</li>
<li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648806164831-f5aad4cc-46cc-4940-83e5-d304b0afa18e.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=383&id=u2d46b0c5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=383&originWidth=234&originalType=binary&ratio=1&rotation=0&showTitle=false&size=359526&status=done&style=none&taskId=u4a2f1a76-e4d8-4ced-9fc2-7251a8c99c5&title=&width=234" alt="image.png"></p>
<ol start="3">
<li>配置信息相关</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648806294535-f1237e00-9ada-43d0-8a4c-2e283e0ec09b.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=107&id=uf7aa95fb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=107&originWidth=578&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7669&status=done&style=none&taskId=u8d2a29b6-f466-414a-8244-bf61c16a34c&title=&width=578" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648806393052-c259106c-1c01-432f-84b3-f64660de2a0e.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=75&id=u5c50bfc3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=75&originWidth=422&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4304&status=done&style=none&taskId=u87f96674-eeab-4b3e-b4fc-6c17c75f23d&title=&width=422" alt="image.png"><br />appendfsync always<br />始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br />appendfsync everysec<br />每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br />appendfsync no<br />redis不主动进行同步，把同步时机交给操作系统。</p>
<ol start="4">
<li>备份使用方式</li>
</ol>
<p>同rdb；<br />异常恢复使用：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648806502161-cb24d4fa-aea5-42e7-a490-791bde455469.png#clientId=uae540855-5520-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=158&id=ufa61942e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=158&originWidth=416&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9689&status=done&style=none&taskId=ua89e16c9-832d-4cd7-adae-b56fcfa671e&title=&width=416" alt="image.png"><br><a name="k06e1"></a></p>
<h2 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h2><ol>
<li>优先级？</li>
</ol>
<p>rdb默认开启，aof默认关闭；官方推荐都开启，优先aof，因为能保证数据的完整性</p>
<ol start="2">
<li><p>rdb</p>
<ul>
<li><p>适合大规模的数据恢复</p>
</li>
<li><p>对数据完整性和一致性要求不高更适合使用</p>
</li>
<li><p>节省磁盘空间</p>
</li>
<li><p>恢复速度快</p>
</li>
<li><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p>
</li>
<li><p>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</p>
</li>
<li><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</li>
</ul>
</li>
<li><p>aof</p>
<ul>
<li><p>备份机制更稳健，丢失数据概率更低。</p>
</li>
<li><p>可读的日志文本，通过操作AOF稳健，可以处理误操作</p>
</li>
<li><p>比起RDB占用更多的磁盘空间。</p>
</li>
<li><p>恢复备份速度要慢。</p>
</li>
<li><p>每次读写都同步的话，有一定的性能压力。</p>
</li>
<li><p>存在个别Bug，造成恢复不能。</p>
</li>
</ul>
</li>
</ol>
<p><a name="glPhg"></a></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><ol>
<li>简介</li>
</ol>
<p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</p>
<ul>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648807938667-2126e748-74f8-4560-bfd8-1556beb9d9af.png#clientId=ubb72c0e7-b548-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=206&id=u45e0ce81&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&size=267690&status=done&style=none&taskId=u95e439a2-d074-4d89-9e61-3d65af6f554&title=&width=324" alt="image.png"><br />一般是一主多从，多个主可以通过集群来解决</p>
<ol start="2">
<li>简单的实现（一主两从）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648864790771-5193cde2-eae9-40f1-9185-caa2099b45e2.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=214&id=u0b197d2d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=589&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25682&status=done&style=none&taskId=uab6f67f1-7d02-4a49-88cd-ca897e2dcfe&title=&width=589" alt="image.png"><br />配置文件信息如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648864847245-9f1a56be-0318-41b8-b8fa-1153c4da7e2a.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=83&id=uc3b906d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=83&originWidth=274&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3266&status=done&style=none&taskId=uc3d9ade6-b65e-4fa8-8ce9-11bd1c16a5d&title=&width=274" alt="image.png"><br />启动<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648865226020-01c0d6cb-819f-4c57-9d28-b1fa4bf00f34.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=162&id=u47552c63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=162&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16893&status=done&style=none&taskId=ua54e272b-b67f-4478-aa98-6968a9a4c2a&title=&width=675" alt="image.png"><br />进入客户端之后，查看主从复制相关信息<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648865630642-c901109d-6a8a-4728-9efa-36df64b9ed12.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=219&id=u5d4935dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=219&originWidth=537&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13090&status=done&style=none&taskId=u39bff67a-62d4-44d5-b757-c1aad324315&title=&width=537" alt="image.png"><br />可以发现，此时全部都是主机，设置从机的命令：<code>slaveof  &lt;ip&gt;&lt;port&gt;</code><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648865834172-4647a5b8-e0e5-4805-96bf-04d3130d1083.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=u6109724a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=465&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13643&status=done&style=none&taskId=u4027846e-e084-41ef-905e-4e10dc0a83c&title=&width=465" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648865892851-e451bd8f-eb14-4585-914b-be1199fc22f5.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=396&id=u7d49ebb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19826&status=done&style=none&taskId=u6f47634c-cded-4ab5-8f3b-61a9904f8de&title=&width=538" alt="image.png"><br />简单查询数据，可以发现从机已经可以获取到主机新增的数据了（<strong>主机连接之前的获取不到</strong>），且从机无法进行写操作，只有读操作。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648866131948-ff3accd3-ecf2-4d0b-adb3-b9454f6590e9.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=82&id=ufbdea284&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=494&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5469&status=done&style=none&taskId=u28aff42e-6dbb-4e97-8c21-aadde9132be&title=&width=494" alt="image.png"><br />主从复制支持套娃，<strong>从机也可以当其他从机的主机（当然还是不能写，小弟就是小弟）</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648867860710-fcec0c88-bf90-49b3-8e1a-f70c8de36e9f.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=416&id=u4e112fb8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=658&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29717&status=done&style=none&taskId=u2d120bab-a6d3-4e6f-bcde-9f134b0e825&title=&width=658" alt="image.png"></p>
<ol start="3">
<li>从机挂掉分析<ul>
<li>挂掉之后再重启，默认是一个新的主机</li>
<li>重新连接主机之后，<strong>会把自己错过的重新复制一遍数据（之前连接时候的数据还在，因为持久化）</strong>，比如主机1，2，3；复制就是3，2，1（<strong>主机连接之前的获取不到</strong>）</li>
</ul>
</li>
<li>主机挂掉分析<ul>
<li>挂掉再连接还是之前的主机</li>
<li>从机在主机挂掉期间，不会自动变成主机，还是从机，相关信息可以看到主机挂了</li>
</ul>
</li>
<li>复制原理</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648867011462-629f12e7-a5d5-4d10-96af-67e310e9ff42.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=uac553ea3&margin=%5Bobject%20Object%5D&name=03-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png&originHeight=620&originWidth=1376&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16292&status=done&style=none&taskId=ua7745bdd-b2b7-477e-8a28-3f9744e429a&title=&width=609" alt="03-主从复制原理.png"></p>
<ol start="6">
<li>哨兵模式<ol>
<li>反客为主</li>
</ol>
</li>
</ol>
<p>当主机挂掉，可以使用命令<code>slaveof no one</code>来将从机升级成为主机，每次都要手动执行，不方便</p>
<ol start="2">
<li>哨兵模式（上述升级版）<ol>
<li>实现</li>
</ol>
</li>
</ol>
<p>设置好一主两从，新增文件sentinel.conf<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648869827721-8a549aa3-9be1-48ba-8293-a5bd12051eed.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=47&id=u22d2826d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=47&originWidth=351&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2374&status=done&style=none&taskId=ue10552c8-497c-4cc3-b073-87518ec8019&title=&width=351" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648870373239-e5e3b86d-f67e-411d-9c62-f4750068179c.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=392&id=uf8194831&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39532&status=done&style=none&taskId=u034aef6d-be76-4726-bf83-57dc9f0a7c8&title=&width=591" alt="image.png"><br />将主机挂掉之后，6380自动升级成为主机<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648870440257-24a102d3-7ae4-48e6-bde0-ee1afed59c1b.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=110&id=u495eae2d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=152&originWidth=831&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21748&status=done&style=none&taskId=uddc6606b-22b9-4ebb-98b1-68913267e8b&title=&width=601" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648870561523-ca2cb646-d128-4044-b0ce-62dd107dc1c2.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=99&id=u5ed9eb70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7206&status=done&style=none&taskId=u0d50d801-28d8-4e55-b062-54cc322f9f4&title=&width=396" alt="image.png"></p>
<pre><code>  2. 分析
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648870600742-738209a7-f940-41a0-9d8e-a79580832251.png#clientId=uda81e349-2c44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=ue6642fe4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=667274&status=done&style=none&taskId=u2d27035b-1a8f-4929-8c1e-13f622f3eca&title=&width=553" alt="image.png"><br />偏移量大小指获得主机数据全面，越全面越大<br />runid，每个redis实例都会生成40位</p>
<pre><code>  3. 问题
</code></pre>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<ol start="3">
<li><p>jedis代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title">getJedisFromSentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedisSentinelPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">        Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig jedisPoolConfig =<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">        jedisPoolConfig.setBlockWhenExhausted(<span class="keyword">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">        jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line"></span><br><span class="line">        jedisSentinelPool=<span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="GUdDM"></a></p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1></li>
<li><p>简介</p>
</li>
</ol>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，<strong>每个节点存储总数据的1/N</strong>。<strong>无论哪个主机写数据，其他主机都能读到数据。</strong><br />Redis 集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。实现redis的<strong>容量水平扩容</strong>，和<strong>并发写操作的分摊</strong></p>
<ol start="2">
<li>简单实现</li>
</ol>
<p>首先删除之前生成的rdb,aof文件，重新写六个配置文件（:%s/6379/6380快速替换）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648881347666-50c01f5d-7320-4e88-b1e1-6416ef886b93.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=122&id=ua2da2993&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9955&status=done&style=none&taskId=ub80c11bd-4456-4b49-9187-eb50cedf0af&title=&width=469" alt="image.png"><br />将六个redis实例启动，到redis.6.2.6/src目录下然后合体<br /><code>redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</code>一个集群至少要有三个主节点。选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648882425234-c00473d6-c3b2-4037-b323-0ae4dbc4e07c.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=609&id=u14d269c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=833&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94542&status=done&style=none&taskId=uaed59558-5cc9-4b19-a071-79f50050c2d&title=&width=626" alt="image.png"><br />查看集群相关信息<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648883985300-e0c6238c-a442-439b-bbf8-b1f79450993d.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=uc986db01&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=841&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26301&status=done&style=none&taskId=u46307eb6-81e5-4e34-9364-286a1334962&title=&width=693" alt="image.png"><br />插槽的概念slots，一共16384，每个节点平均分，插入的值会自动转到对应节点下<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648884358614-be6e4902-bec8-4a61-9154-c37011a947db.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=155&id=ua306757e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25162&status=done&style=none&taskId=ub1f1cced-1c7c-4a04-aa2b-0284d5736d7&title=&width=673" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648885122084-1b58ef27-cd6f-44c0-a774-9725f06c7f2c.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=uc8a087c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=714&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29121&status=done&style=none&taskId=u62798e80-753d-47bc-9472-2d6ff90476e&title=&width=680" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648889837952-f37ea733-8c31-43e0-aab4-e5b845830fd7.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=47&id=u340bd26b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=47&originWidth=450&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3066&status=done&style=none&taskId=uc6ed2201-a3c8-482e-9ee6-97ddfd2613d&title=&width=450" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648889875481-b38a1d94-1ca0-4f57-a309-f6e80745b95f.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=417&id=u7ee5abd8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=910&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28974&status=done&style=none&taskId=u0b238606-276b-42dd-94b3-c6a1eb3e475&title=&width=643" alt="image.png"></p>
<ol start="3">
<li>异常处理</li>
</ol>
<ul>
<li>主节点挂掉，从节点自动升级成为主节点</li>
<li>原来的主节点恢复也只是从节点</li>
<li>要是一段插槽的主从节点全部挂掉，怎么处理？<ul>
<li>取决与redis.conf中的<strong>cluster-require-full-coverage</strong></li>
<li>若为yes则整个都挂掉，反之为no只有该段插槽全都无法使用<br><a name="xaaEa"></a><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><a name="cR1u6"></a><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2></li>
</ul>
</li>
</ul>
<ol>
<li>问题描述</li>
</ol>
<p>一直请求不存在的数据，导致缓存几乎失效，一直向缓存和数据库中查询不存在的数据，返回空的数据，redis又不会存储空结果，服务器压力过大<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648892822303-1ce42d79-cc84-4b6e-bd89-fe47155a73c2.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=0.9665&crop=0.76&from=paste&height=684&id=uacf2ffcc&margin=%5Bobject%20Object%5D&name=05-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png&originHeight=708&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160487&status=done&style=none&taskId=u68bc1b0c-ea54-46dd-b44b-a847e7b2435&title=&width=1332" alt="05-缓存穿透.png"></p>
<ol start="2">
<li>解决措施</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648893220437-6176781f-ce6a-4d27-8331-1a2067679453.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=402&id=u042b964e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44641&status=done&style=none&taskId=u0a04b37d-a502-43af-ac8b-d02f15f79dd&title=&width=507" alt="image.png"><br><a name="ZyAxM"></a></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ol>
<li>问题描述</li>
</ol>
<p>redis正常运行，但刚好一个key过期的时候，大量使用这个key的请求涌入，可能压垮服务器<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648893598495-090f292e-69ba-4806-91fd-52586992d67d.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=0.9651&crop=0.6947&from=paste&height=683&id=ua13034fb&margin=%5Bobject%20Object%5D&name=06-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png&originHeight=708&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120604&status=done&style=none&taskId=ua71b13f7-b9c1-43d4-ba3e-69554e7e44f&title=&width=1330" alt="06-缓存击穿.png"></p>
<ol start="2">
<li>解决方式</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648893676537-013ce44b-4380-4a8f-9795-5a5b0e45fb32.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=707&id=u55c7c011&margin=%5Bobject%20Object%5D&name=image.png&originHeight=707&originWidth=605&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75907&status=done&style=none&taskId=u868e97ac-6f4a-49d8-a785-d4cb83d90de&title=&width=605" alt="image.png"><br><a name="hyx8i"></a></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ol>
<li>问题描述</li>
</ol>
<p>某个极端时间内，大量key过期，造成服务器压力瞬间过大<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648893937035-1bd8a984-bc88-4492-a2c2-50a6533c0cf5.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=0.9397&crop=0.7548&from=paste&height=665&id=ufa498b1c&margin=%5Bobject%20Object%5D&name=07-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png&originHeight=708&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141331&status=done&style=none&taskId=u647c8675-2938-4b38-84d6-0ee8f944afd&title=&width=1295" alt="07-缓存雪崩.png"></p>
<ol start="2">
<li>解决方案</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1648894033964-28b6eaf3-de5b-4733-a6d1-b31b86ad5dd3.png#clientId=ud5d8fd42-4601-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=336&id=udb77d739&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=505&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32200&status=done&style=none&taskId=u1e8764df-5124-4a8a-ba46-2d7ec44187a&title=&width=505" alt="image.png"></p>
<p><a name="PVhan"></a></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ol>
<li>简介</li>
</ol>
<p>分布式系统多线程，多进程分布在不同不同机器上，单纯的Java api无法提供分布式锁。可使用redis来实现</p>
<ol start="2">
<li>简单使用</li>
</ol>
<p><code>set user 11 nx ex 10</code>(原子操作，防止执行一个命令执行就挂掉的极端情况）<br />nx上锁，ex设置过期时间</p>
<ol start="3">
<li>可能出现的问题—&gt;误删锁？</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1649234227386-5101822b-2579-485a-8aa9-8853d795db6c.png#clientId=u5b6aea5e-c01f-4&crop=0.0383&crop=0.0507&crop=0.9463&crop=0.8657&from=paste&height=304&id=u1cf2839a&margin=%5Bobject%20Object%5D&name=09-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88UUID%E9%98%B2%E8%AF%AF%E5%88%A0%EF%BC%89.png&originHeight=708&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23787&status=done&style=none&taskId=u068be09a-20eb-40c9-9108-43229861f28&title=&width=592" alt="09-分布式锁（UUID防误删）.png"><br />大概描述就是a由于卡顿或者其他因素锁自动释放了，b拿到锁之后，此时a认为该释放锁了，将b的锁又手动释放了。<br />解决：添加一个uuid，只有执行释放锁操作的uuid和获取该锁的uuid一样时才执行该操作</p>
<p>上述操作存在一个问题，就是可能a卡了一下自动释放了，然后刚好判断uuid一样a把b刚拿到的锁释放了，原因是因为缺乏原子性；使用lua脚本可解决<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22078302/1649234773183-aa5734eb-e8eb-40b4-99b1-7442f3852f9f.png#clientId=u5b6aea5e-c01f-4&crop=0&crop=0&crop=0.7413&crop=0.8669&from=paste&height=525&id=u605a56a3&margin=%5Bobject%20Object%5D&name=10-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%89.png&originHeight=708&originWidth=1378&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17460&status=done&style=none&taskId=ub5c44e66-d385-4f8f-9927-fc6d9f9842b&title=&width=1021" alt="10-分布式锁（原子操作）.png"><br><a name="dtMSl"></a></p>
<h1 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h1><ol>
<li>ACL</li>
</ol>
<ul>
<li>就是对操作权限进行更细化的控制</li>
<li>acl list查看用户权限列表</li>
<li>acl cat命令查看添加权限指令类别（加参数类型名可以查看类型下具体命令）</li>
<li>acl whoami命令查看当前用户</li>
<li>aclsetuser命令创建和编辑用户ACL</li>
</ul>
<ol start="2">
<li>多线程</li>
</ol>
<ul>
<li>并不是单线程变成多线程的意思</li>
<li>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong></li>
</ul>
<ol start="3">
<li>工具支持cluster</li>
</ol>
<ul>
<li>无需再安装ruby环境</li>
</ul>
<ol start="4">
<li>RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</li>
<li>Client side caching客户端缓存：基于RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</li>
<li>Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</li>
<li>Modules API</li>
</ol>
<p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>
<p><a name="gx8rt"></a></p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>感谢尚硅谷的视频：<a href="https://www.bilibili.com/video/BV1Rv41177Af">https://www.bilibili.com/video/BV1Rv41177Af</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
